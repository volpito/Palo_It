{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar createProxy = require(\"./proxy\");\n\nvar extend = require(\"./util/core/extend\");\n\nvar functionName = require(\"@sinonjs/commons\").functionName;\n\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n\nvar deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n\nvar isEsModule = require(\"./util/core/is-es-module\");\n\nvar proxyCallUtil = require(\"./proxy-call-util\");\n\nvar walkObject = require(\"./util/core/walk-object\");\n\nvar wrapMethod = require(\"./util/core/wrap-method\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n/* cache references to library methods so that they also can be stubbed without problems */\n\n\nvar forEach = arrayProto.forEach;\nvar pop = arrayProto.pop;\nvar push = arrayProto.push;\nvar slice = arrayProto.slice;\nvar filter = Array.prototype.filter;\nvar uuid = 0;\n\nfunction matches(fake, args, strict) {\n  var margs = fake.matchingArguments;\n\n  if (margs.length <= args.length && deepEqual(slice(args, 0, margs.length), margs)) {\n    return !strict || margs.length === args.length;\n  }\n\n  return false;\n} // Public API\n\n\nvar spyApi = {\n  withArgs: function withArgs() {\n    var args = slice(arguments);\n    var matching = pop(this.matchingFakes(args, true));\n\n    if (matching) {\n      return matching;\n    }\n\n    var original = this;\n    var fake = this.instantiateFake();\n    fake.matchingArguments = args;\n    fake.parent = this;\n    push(this.fakes, fake);\n\n    fake.withArgs = function () {\n      return original.withArgs.apply(original, arguments);\n    };\n\n    forEach(original.args, function (arg, i) {\n      if (!matches(fake, arg)) {\n        return;\n      }\n\n      proxyCallUtil.incrementCallCount(fake);\n      push(fake.thisValues, original.thisValues[i]);\n      push(fake.args, arg);\n      push(fake.returnValues, original.returnValues[i]);\n      push(fake.exceptions, original.exceptions[i]);\n      push(fake.callIds, original.callIds[i]);\n    });\n    proxyCallUtil.createCallProperties(fake);\n    return fake;\n  },\n  // Override proxy default implementation\n  matchingFakes: function matchingFakes(args, strict) {\n    return filter.call(this.fakes, function (fake) {\n      return matches(fake, args, strict);\n    });\n  }\n};\n/* eslint-disable @sinonjs/no-prototype-methods/no-prototype-methods */\n\nvar delegateToCalls = proxyCallUtil.delegateToCalls;\ndelegateToCalls(spyApi, \"callArg\", false, \"callArgWith\", true, function () {\n  throw new Error(\"\".concat(this.toString(), \" cannot call arg since it was not yet invoked.\"));\n});\nspyApi.callArgWith = spyApi.callArg;\ndelegateToCalls(spyApi, \"callArgOn\", false, \"callArgOnWith\", true, function () {\n  throw new Error(\"\".concat(this.toString(), \" cannot call arg since it was not yet invoked.\"));\n});\nspyApi.callArgOnWith = spyApi.callArgOn;\ndelegateToCalls(spyApi, \"throwArg\", false, \"throwArg\", false, function () {\n  throw new Error(\"\".concat(this.toString(), \" cannot throw arg since it was not yet invoked.\"));\n});\ndelegateToCalls(spyApi, \"yield\", false, \"yield\", true, function () {\n  throw new Error(\"\".concat(this.toString(), \" cannot yield since it was not yet invoked.\"));\n}); // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\n\nspyApi.invokeCallback = spyApi.yield;\ndelegateToCalls(spyApi, \"yieldOn\", false, \"yieldOn\", true, function () {\n  throw new Error(\"\".concat(this.toString(), \" cannot yield since it was not yet invoked.\"));\n});\ndelegateToCalls(spyApi, \"yieldTo\", false, \"yieldTo\", true, function (property) {\n  throw new Error(\"\".concat(this.toString(), \" cannot yield to '\").concat(valueToString(property), \"' since it was not yet invoked.\"));\n});\ndelegateToCalls(spyApi, \"yieldToOn\", false, \"yieldToOn\", true, function (property) {\n  throw new Error(\"\".concat(this.toString(), \" cannot yield to '\").concat(valueToString(property), \"' since it was not yet invoked.\"));\n});\n\nfunction createSpy(func) {\n  var name;\n  var funk = func;\n\n  if (typeof funk !== \"function\") {\n    funk = function funk() {\n      return;\n    };\n  } else {\n    name = functionName(funk);\n  }\n\n  var proxy = createProxy(funk, funk); // Inherit spy API:\n\n  extend.nonEnum(proxy, spyApi);\n  extend.nonEnum(proxy, {\n    displayName: name || \"spy\",\n    fakes: [],\n    instantiateFake: createSpy,\n    id: \"spy#\".concat(uuid++)\n  });\n  return proxy;\n}\n\nfunction spy(object, property, types) {\n  var descriptor, methodDesc;\n\n  if (isEsModule(object)) {\n    throw new TypeError(\"ES Modules cannot be spied\");\n  }\n\n  if (!property && typeof object === \"function\") {\n    return createSpy(object);\n  }\n\n  if (!property && _typeof(object) === \"object\") {\n    return walkObject(spy, object);\n  }\n\n  if (!object && !property) {\n    return createSpy(function () {\n      return;\n    });\n  }\n\n  if (!types) {\n    return wrapMethod(object, property, createSpy(object[property]));\n  }\n\n  descriptor = {};\n  methodDesc = getPropertyDescriptor(object, property);\n  forEach(types, function (type) {\n    descriptor[type] = createSpy(methodDesc[type]);\n  });\n  return wrapMethod(object, property, descriptor);\n}\n\nextend(spy, spyApi);\nmodule.exports = spy;","map":null,"metadata":{},"sourceType":"module"}