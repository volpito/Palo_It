{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Preprocessor = require('./preprocessor');\n\nvar unicode = require('../common/unicode');\n\nvar neTree = require('./named-entity-data');\n\nvar ERR = require('../common/error-codes'); //Aliases\n\n\nvar $ = unicode.CODE_POINTS;\nvar $$ = unicode.CODE_POINT_SEQUENCES; //C1 Unicode control character reference replacements\n\nvar C1_CONTROLS_REFERENCE_REPLACEMENTS = {\n  0x80: 0x20ac,\n  0x82: 0x201a,\n  0x83: 0x0192,\n  0x84: 0x201e,\n  0x85: 0x2026,\n  0x86: 0x2020,\n  0x87: 0x2021,\n  0x88: 0x02c6,\n  0x89: 0x2030,\n  0x8a: 0x0160,\n  0x8b: 0x2039,\n  0x8c: 0x0152,\n  0x8e: 0x017d,\n  0x91: 0x2018,\n  0x92: 0x2019,\n  0x93: 0x201c,\n  0x94: 0x201d,\n  0x95: 0x2022,\n  0x96: 0x2013,\n  0x97: 0x2014,\n  0x98: 0x02dc,\n  0x99: 0x2122,\n  0x9a: 0x0161,\n  0x9b: 0x203a,\n  0x9c: 0x0153,\n  0x9e: 0x017e,\n  0x9f: 0x0178\n}; // Named entity tree flags\n\nvar HAS_DATA_FLAG = 1 << 0;\nvar DATA_DUPLET_FLAG = 1 << 1;\nvar HAS_BRANCHES_FLAG = 1 << 2;\nvar MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG; //States\n\nvar DATA_STATE = 'DATA_STATE';\nvar RCDATA_STATE = 'RCDATA_STATE';\nvar RAWTEXT_STATE = 'RAWTEXT_STATE';\nvar SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';\nvar PLAINTEXT_STATE = 'PLAINTEXT_STATE';\nvar TAG_OPEN_STATE = 'TAG_OPEN_STATE';\nvar END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';\nvar TAG_NAME_STATE = 'TAG_NAME_STATE';\nvar RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';\nvar RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';\nvar RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';\nvar RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';\nvar RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';\nvar RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';\nvar SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';\nvar SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';\nvar SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';\nvar SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';\nvar SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';\nvar SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';\nvar SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';\nvar SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';\nvar SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';\nvar SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';\nvar SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';\nvar SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';\nvar BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';\nvar ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';\nvar AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';\nvar BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';\nvar ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';\nvar ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';\nvar ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';\nvar AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';\nvar SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';\nvar BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';\nvar MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';\nvar COMMENT_START_STATE = 'COMMENT_START_STATE';\nvar COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';\nvar COMMENT_STATE = 'COMMENT_STATE';\nvar COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';\nvar COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';\nvar COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';\nvar COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';\nvar COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';\nvar COMMENT_END_STATE = 'COMMENT_END_STATE';\nvar COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';\nvar DOCTYPE_STATE = 'DOCTYPE_STATE';\nvar BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';\nvar DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';\nvar AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';\nvar AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';\nvar BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';\nvar DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';\nvar DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';\nvar AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';\nvar BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';\nvar AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';\nvar BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';\nvar DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';\nvar DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';\nvar AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';\nvar BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';\nvar CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';\nvar CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';\nvar CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';\nvar CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';\nvar NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';\nvar AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';\nvar NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';\nvar HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';\nvar DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';\nvar HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';\nvar DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';\nvar NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE'; //Utils\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\n\nfunction isWhitespace(cp) {\n  return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;\n}\n\nfunction isAsciiDigit(cp) {\n  return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;\n}\n\nfunction isAsciiUpper(cp) {\n  return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;\n}\n\nfunction isAsciiLower(cp) {\n  return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;\n}\n\nfunction isAsciiLetter(cp) {\n  return isAsciiLower(cp) || isAsciiUpper(cp);\n}\n\nfunction isAsciiAlphaNumeric(cp) {\n  return isAsciiLetter(cp) || isAsciiDigit(cp);\n}\n\nfunction isAsciiUpperHexDigit(cp) {\n  return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;\n}\n\nfunction isAsciiLowerHexDigit(cp) {\n  return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;\n}\n\nfunction isAsciiHexDigit(cp) {\n  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);\n}\n\nfunction toAsciiLowerCodePoint(cp) {\n  return cp + 0x0020;\n} //NOTE: String.fromCharCode() function can handle only characters from BMP subset.\n//So, we need to workaround this manually.\n//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)\n\n\nfunction toChar(cp) {\n  if (cp <= 0xffff) {\n    return String.fromCharCode(cp);\n  }\n\n  cp -= 0x10000;\n  return String.fromCharCode(cp >>> 10 & 0x3ff | 0xd800) + String.fromCharCode(0xdc00 | cp & 0x3ff);\n}\n\nfunction toAsciiLowerChar(cp) {\n  return String.fromCharCode(toAsciiLowerCodePoint(cp));\n}\n\nfunction findNamedEntityTreeBranch(nodeIx, cp) {\n  var branchCount = neTree[++nodeIx];\n  var lo = ++nodeIx;\n  var hi = lo + branchCount - 1;\n\n  while (lo <= hi) {\n    var mid = lo + hi >>> 1;\n    var midCp = neTree[mid];\n\n    if (midCp < cp) {\n      lo = mid + 1;\n    } else if (midCp > cp) {\n      hi = mid - 1;\n    } else {\n      return neTree[mid + branchCount];\n    }\n  }\n\n  return -1;\n} //Tokenizer\n\n\nvar Tokenizer = /*#__PURE__*/function () {\n  function Tokenizer() {\n    _classCallCheck(this, Tokenizer);\n\n    this.preprocessor = new Preprocessor();\n    this.tokenQueue = [];\n    this.allowCDATA = false;\n    this.state = DATA_STATE;\n    this.returnState = '';\n    this.charRefCode = -1;\n    this.tempBuff = [];\n    this.lastStartTagName = '';\n    this.consumedAfterSnapshot = -1;\n    this.active = false;\n    this.currentCharacterToken = null;\n    this.currentToken = null;\n    this.currentAttr = null;\n  } //Errors\n\n\n  _createClass(Tokenizer, [{\n    key: \"_err\",\n    value: function _err() {// NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n  }, {\n    key: \"_errOnNextCodePoint\",\n    value: function _errOnNextCodePoint(err) {\n      this._consume();\n\n      this._err(err);\n\n      this._unconsume();\n    } //API\n\n  }, {\n    key: \"getNextToken\",\n    value: function getNextToken() {\n      while (!this.tokenQueue.length && this.active) {\n        this.consumedAfterSnapshot = 0;\n\n        var cp = this._consume();\n\n        if (!this._ensureHibernation()) {\n          this[this.state](cp);\n        }\n      }\n\n      return this.tokenQueue.shift();\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, isLastChunk) {\n      this.active = true;\n      this.preprocessor.write(chunk, isLastChunk);\n    }\n  }, {\n    key: \"insertHtmlAtCurrentPos\",\n    value: function insertHtmlAtCurrentPos(chunk) {\n      this.active = true;\n      this.preprocessor.insertHtmlAtCurrentPos(chunk);\n    } //Hibernation\n\n  }, {\n    key: \"_ensureHibernation\",\n    value: function _ensureHibernation() {\n      if (this.preprocessor.endOfChunkHit) {\n        for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {\n          this.preprocessor.retreat();\n        }\n\n        this.active = false;\n        this.tokenQueue.push({\n          type: Tokenizer.HIBERNATION_TOKEN\n        });\n        return true;\n      }\n\n      return false;\n    } //Consumption\n\n  }, {\n    key: \"_consume\",\n    value: function _consume() {\n      this.consumedAfterSnapshot++;\n      return this.preprocessor.advance();\n    }\n  }, {\n    key: \"_unconsume\",\n    value: function _unconsume() {\n      this.consumedAfterSnapshot--;\n      this.preprocessor.retreat();\n    }\n  }, {\n    key: \"_reconsumeInState\",\n    value: function _reconsumeInState(state) {\n      this.state = state;\n\n      this._unconsume();\n    }\n  }, {\n    key: \"_consumeSequenceIfMatch\",\n    value: function _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {\n      var consumedCount = 0;\n      var isMatch = true;\n      var patternLength = pattern.length;\n      var patternPos = 0;\n      var cp = startCp;\n      var patternCp = void 0;\n\n      for (; patternPos < patternLength; patternPos++) {\n        if (patternPos > 0) {\n          cp = this._consume();\n          consumedCount++;\n        }\n\n        if (cp === $.EOF) {\n          isMatch = false;\n          break;\n        }\n\n        patternCp = pattern[patternPos];\n\n        if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {\n          isMatch = false;\n          break;\n        }\n      }\n\n      if (!isMatch) {\n        while (consumedCount--) {\n          this._unconsume();\n        }\n      }\n\n      return isMatch;\n    } //Temp buffer\n\n  }, {\n    key: \"_isTempBufferEqualToScriptString\",\n    value: function _isTempBufferEqualToScriptString() {\n      if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.tempBuff.length; i++) {\n        if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    } //Token creation\n\n  }, {\n    key: \"_createStartTagToken\",\n    value: function _createStartTagToken() {\n      this.currentToken = {\n        type: Tokenizer.START_TAG_TOKEN,\n        tagName: '',\n        selfClosing: false,\n        ackSelfClosing: false,\n        attrs: []\n      };\n    }\n  }, {\n    key: \"_createEndTagToken\",\n    value: function _createEndTagToken() {\n      this.currentToken = {\n        type: Tokenizer.END_TAG_TOKEN,\n        tagName: '',\n        selfClosing: false,\n        attrs: []\n      };\n    }\n  }, {\n    key: \"_createCommentToken\",\n    value: function _createCommentToken() {\n      this.currentToken = {\n        type: Tokenizer.COMMENT_TOKEN,\n        data: ''\n      };\n    }\n  }, {\n    key: \"_createDoctypeToken\",\n    value: function _createDoctypeToken(initialName) {\n      this.currentToken = {\n        type: Tokenizer.DOCTYPE_TOKEN,\n        name: initialName,\n        forceQuirks: false,\n        publicId: null,\n        systemId: null\n      };\n    }\n  }, {\n    key: \"_createCharacterToken\",\n    value: function _createCharacterToken(type, ch) {\n      this.currentCharacterToken = {\n        type: type,\n        chars: ch\n      };\n    }\n  }, {\n    key: \"_createEOFToken\",\n    value: function _createEOFToken() {\n      this.currentToken = {\n        type: Tokenizer.EOF_TOKEN\n      };\n    } //Tag attributes\n\n  }, {\n    key: \"_createAttr\",\n    value: function _createAttr(attrNameFirstCh) {\n      this.currentAttr = {\n        name: attrNameFirstCh,\n        value: ''\n      };\n    }\n  }, {\n    key: \"_leaveAttrName\",\n    value: function _leaveAttrName(toState) {\n      if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {\n        this.currentToken.attrs.push(this.currentAttr);\n      } else {\n        this._err(ERR.duplicateAttribute);\n      }\n\n      this.state = toState;\n    }\n  }, {\n    key: \"_leaveAttrValue\",\n    value: function _leaveAttrValue(toState) {\n      this.state = toState;\n    } //Token emission\n\n  }, {\n    key: \"_emitCurrentToken\",\n    value: function _emitCurrentToken() {\n      this._emitCurrentCharacterToken();\n\n      var ct = this.currentToken;\n      this.currentToken = null; //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.\n\n      if (ct.type === Tokenizer.START_TAG_TOKEN) {\n        this.lastStartTagName = ct.tagName;\n      } else if (ct.type === Tokenizer.END_TAG_TOKEN) {\n        if (ct.attrs.length > 0) {\n          this._err(ERR.endTagWithAttributes);\n        }\n\n        if (ct.selfClosing) {\n          this._err(ERR.endTagWithTrailingSolidus);\n        }\n      }\n\n      this.tokenQueue.push(ct);\n    }\n  }, {\n    key: \"_emitCurrentCharacterToken\",\n    value: function _emitCurrentCharacterToken() {\n      if (this.currentCharacterToken) {\n        this.tokenQueue.push(this.currentCharacterToken);\n        this.currentCharacterToken = null;\n      }\n    }\n  }, {\n    key: \"_emitEOFToken\",\n    value: function _emitEOFToken() {\n      this._createEOFToken();\n\n      this._emitCurrentToken();\n    } //Characters emission\n    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).\n    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.\n    //If we have a sequence of characters that belong to the same group, parser can process it\n    //as a single solid character token.\n    //So, there are 3 types of character tokens in parse5:\n    //1)NULL_CHARACTER_TOKEN - \\u0000-character sequences (e.g. '\\u0000\\u0000\\u0000')\n    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\\n  \\r\\t   \\f')\n    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')\n\n  }, {\n    key: \"_appendCharToCurrentCharacterToken\",\n    value: function _appendCharToCurrentCharacterToken(type, ch) {\n      if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {\n        this._emitCurrentCharacterToken();\n      }\n\n      if (this.currentCharacterToken) {\n        this.currentCharacterToken.chars += ch;\n      } else {\n        this._createCharacterToken(type, ch);\n      }\n    }\n  }, {\n    key: \"_emitCodePoint\",\n    value: function _emitCodePoint(cp) {\n      var type = Tokenizer.CHARACTER_TOKEN;\n\n      if (isWhitespace(cp)) {\n        type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;\n      } else if (cp === $.NULL) {\n        type = Tokenizer.NULL_CHARACTER_TOKEN;\n      }\n\n      this._appendCharToCurrentCharacterToken(type, toChar(cp));\n    }\n  }, {\n    key: \"_emitSeveralCodePoints\",\n    value: function _emitSeveralCodePoints(codePoints) {\n      for (var i = 0; i < codePoints.length; i++) {\n        this._emitCodePoint(codePoints[i]);\n      }\n    } //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.\n    //So we can avoid additional checks here.\n\n  }, {\n    key: \"_emitChars\",\n    value: function _emitChars(ch) {\n      this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);\n    } // Character reference helpers\n\n  }, {\n    key: \"_matchNamedCharacterReference\",\n    value: function _matchNamedCharacterReference(startCp) {\n      var result = null;\n      var excess = 1;\n      var i = findNamedEntityTreeBranch(0, startCp);\n      this.tempBuff.push(startCp);\n\n      while (i > -1) {\n        var current = neTree[i];\n        var inNode = current < MAX_BRANCH_MARKER_VALUE;\n        var nodeWithData = inNode && current & HAS_DATA_FLAG;\n\n        if (nodeWithData) {\n          //NOTE: we use greedy search, so we continue lookup at this point\n          result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];\n          excess = 0;\n        }\n\n        var cp = this._consume();\n\n        this.tempBuff.push(cp);\n        excess++;\n\n        if (cp === $.EOF) {\n          break;\n        }\n\n        if (inNode) {\n          i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;\n        } else {\n          i = cp === current ? ++i : -1;\n        }\n      }\n\n      while (excess--) {\n        this.tempBuff.pop();\n\n        this._unconsume();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_isCharacterReferenceInAttribute\",\n    value: function _isCharacterReferenceInAttribute() {\n      return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;\n    }\n  }, {\n    key: \"_isCharacterReferenceAttributeQuirk\",\n    value: function _isCharacterReferenceAttributeQuirk(withSemicolon) {\n      if (!withSemicolon && this._isCharacterReferenceInAttribute()) {\n        var nextCp = this._consume();\n\n        this._unconsume();\n\n        return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_flushCodePointsConsumedAsCharacterReference\",\n    value: function _flushCodePointsConsumedAsCharacterReference() {\n      if (this._isCharacterReferenceInAttribute()) {\n        for (var i = 0; i < this.tempBuff.length; i++) {\n          this.currentAttr.value += toChar(this.tempBuff[i]);\n        }\n      } else {\n        this._emitSeveralCodePoints(this.tempBuff);\n      }\n\n      this.tempBuff = [];\n    } // State machine\n    // Data state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DATA_STATE,\n    value: function value(cp) {\n      this.preprocessor.dropParsedChunk();\n\n      if (cp === $.LESS_THAN_SIGN) {\n        this.state = TAG_OPEN_STATE;\n      } else if (cp === $.AMPERSAND) {\n        this.returnState = DATA_STATE;\n        this.state = CHARACTER_REFERENCE_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitCodePoint(cp);\n      } else if (cp === $.EOF) {\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } //  RCDATA state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RCDATA_STATE,\n    value: function value(cp) {\n      this.preprocessor.dropParsedChunk();\n\n      if (cp === $.AMPERSAND) {\n        this.returnState = RCDATA_STATE;\n        this.state = CHARACTER_REFERENCE_STATE;\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = RCDATA_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // RAWTEXT state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RAWTEXT_STATE,\n    value: function value(cp) {\n      this.preprocessor.dropParsedChunk();\n\n      if (cp === $.LESS_THAN_SIGN) {\n        this.state = RAWTEXT_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // Script data state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_STATE,\n    value: function value(cp) {\n      this.preprocessor.dropParsedChunk();\n\n      if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // PLAINTEXT state\n    //------------------------------------------------------------------\n\n  }, {\n    key: PLAINTEXT_STATE,\n    value: function value(cp) {\n      this.preprocessor.dropParsedChunk();\n\n      if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // Tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (cp === $.EXCLAMATION_MARK) {\n        this.state = MARKUP_DECLARATION_OPEN_STATE;\n      } else if (cp === $.SOLIDUS) {\n        this.state = END_TAG_OPEN_STATE;\n      } else if (isAsciiLetter(cp)) {\n        this._createStartTagToken();\n\n        this._reconsumeInState(TAG_NAME_STATE);\n      } else if (cp === $.QUESTION_MARK) {\n        this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);\n\n        this._createCommentToken();\n\n        this._reconsumeInState(BOGUS_COMMENT_STATE);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofBeforeTagName);\n\n        this._emitChars('<');\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.invalidFirstCharacterOfTagName);\n\n        this._emitChars('<');\n\n        this._reconsumeInState(DATA_STATE);\n      }\n    } // End tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: END_TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (isAsciiLetter(cp)) {\n        this._createEndTagToken();\n\n        this._reconsumeInState(TAG_NAME_STATE);\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingEndTagName);\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofBeforeTagName);\n\n        this._emitChars('</');\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.invalidFirstCharacterOfTagName);\n\n        this._createCommentToken();\n\n        this._reconsumeInState(BOGUS_COMMENT_STATE);\n      }\n    } // Tag name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: TAG_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n      } else if (cp === $.SOLIDUS) {\n        this.state = SELF_CLOSING_START_TAG_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (isAsciiUpper(cp)) {\n        this.currentToken.tagName += toAsciiLowerChar(cp);\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.tagName += toChar(cp);\n      }\n    } // RCDATA less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RCDATA_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.SOLIDUS) {\n        this.tempBuff = [];\n        this.state = RCDATA_END_TAG_OPEN_STATE;\n      } else {\n        this._emitChars('<');\n\n        this._reconsumeInState(RCDATA_STATE);\n      }\n    } // RCDATA end tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RCDATA_END_TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (isAsciiLetter(cp)) {\n        this._createEndTagToken();\n\n        this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);\n      } else {\n        this._emitChars('</');\n\n        this._reconsumeInState(RCDATA_STATE);\n      }\n    } // RCDATA end tag name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RCDATA_END_TAG_NAME_STATE,\n    value: function value(cp) {\n      if (isAsciiUpper(cp)) {\n        this.currentToken.tagName += toAsciiLowerChar(cp);\n        this.tempBuff.push(cp);\n      } else if (isAsciiLower(cp)) {\n        this.currentToken.tagName += toChar(cp);\n        this.tempBuff.push(cp);\n      } else {\n        if (this.lastStartTagName === this.currentToken.tagName) {\n          if (isWhitespace(cp)) {\n            this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n            return;\n          }\n\n          if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n            return;\n          }\n\n          if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n\n            this._emitCurrentToken();\n\n            return;\n          }\n        }\n\n        this._emitChars('</');\n\n        this._emitSeveralCodePoints(this.tempBuff);\n\n        this._reconsumeInState(RCDATA_STATE);\n      }\n    } // RAWTEXT less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RAWTEXT_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.SOLIDUS) {\n        this.tempBuff = [];\n        this.state = RAWTEXT_END_TAG_OPEN_STATE;\n      } else {\n        this._emitChars('<');\n\n        this._reconsumeInState(RAWTEXT_STATE);\n      }\n    } // RAWTEXT end tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RAWTEXT_END_TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (isAsciiLetter(cp)) {\n        this._createEndTagToken();\n\n        this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);\n      } else {\n        this._emitChars('</');\n\n        this._reconsumeInState(RAWTEXT_STATE);\n      }\n    } // RAWTEXT end tag name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: RAWTEXT_END_TAG_NAME_STATE,\n    value: function value(cp) {\n      if (isAsciiUpper(cp)) {\n        this.currentToken.tagName += toAsciiLowerChar(cp);\n        this.tempBuff.push(cp);\n      } else if (isAsciiLower(cp)) {\n        this.currentToken.tagName += toChar(cp);\n        this.tempBuff.push(cp);\n      } else {\n        if (this.lastStartTagName === this.currentToken.tagName) {\n          if (isWhitespace(cp)) {\n            this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n            return;\n          }\n\n          if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n            return;\n          }\n\n          if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n\n            this.state = DATA_STATE;\n            return;\n          }\n        }\n\n        this._emitChars('</');\n\n        this._emitSeveralCodePoints(this.tempBuff);\n\n        this._reconsumeInState(RAWTEXT_STATE);\n      }\n    } // Script data less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.SOLIDUS) {\n        this.tempBuff = [];\n        this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;\n      } else if (cp === $.EXCLAMATION_MARK) {\n        this.state = SCRIPT_DATA_ESCAPE_START_STATE;\n\n        this._emitChars('<!');\n      } else {\n        this._emitChars('<');\n\n        this._reconsumeInState(SCRIPT_DATA_STATE);\n      }\n    } // Script data end tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_END_TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (isAsciiLetter(cp)) {\n        this._createEndTagToken();\n\n        this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);\n      } else {\n        this._emitChars('</');\n\n        this._reconsumeInState(SCRIPT_DATA_STATE);\n      }\n    } // Script data end tag name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_END_TAG_NAME_STATE,\n    value: function value(cp) {\n      if (isAsciiUpper(cp)) {\n        this.currentToken.tagName += toAsciiLowerChar(cp);\n        this.tempBuff.push(cp);\n      } else if (isAsciiLower(cp)) {\n        this.currentToken.tagName += toChar(cp);\n        this.tempBuff.push(cp);\n      } else {\n        if (this.lastStartTagName === this.currentToken.tagName) {\n          if (isWhitespace(cp)) {\n            this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n            return;\n          } else if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n            return;\n          } else if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n\n            this.state = DATA_STATE;\n            return;\n          }\n        }\n\n        this._emitChars('</');\n\n        this._emitSeveralCodePoints(this.tempBuff);\n\n        this._reconsumeInState(SCRIPT_DATA_STATE);\n      }\n    } // Script data escape start state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPE_START_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;\n\n        this._emitChars('-');\n      } else {\n        this._reconsumeInState(SCRIPT_DATA_STATE);\n      }\n    } // Script data escape start dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPE_START_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;\n\n        this._emitChars('-');\n      } else {\n        this._reconsumeInState(SCRIPT_DATA_STATE);\n      }\n    } // Script data escaped state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;\n\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // Script data escaped dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;\n\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.state = SCRIPT_DATA_ESCAPED_STATE;\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this.state = SCRIPT_DATA_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      }\n    } // Script data escaped dash dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_DASH_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = SCRIPT_DATA_STATE;\n\n        this._emitChars('>');\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.state = SCRIPT_DATA_ESCAPED_STATE;\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this.state = SCRIPT_DATA_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      }\n    } // Script data escaped less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.SOLIDUS) {\n        this.tempBuff = [];\n        this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;\n      } else if (isAsciiLetter(cp)) {\n        this.tempBuff = [];\n\n        this._emitChars('<');\n\n        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);\n      } else {\n        this._emitChars('<');\n\n        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n      }\n    } // Script data escaped end tag open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE,\n    value: function value(cp) {\n      if (isAsciiLetter(cp)) {\n        this._createEndTagToken();\n\n        this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);\n      } else {\n        this._emitChars('</');\n\n        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n      }\n    } // Script data escaped end tag name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE,\n    value: function value(cp) {\n      if (isAsciiUpper(cp)) {\n        this.currentToken.tagName += toAsciiLowerChar(cp);\n        this.tempBuff.push(cp);\n      } else if (isAsciiLower(cp)) {\n        this.currentToken.tagName += toChar(cp);\n        this.tempBuff.push(cp);\n      } else {\n        if (this.lastStartTagName === this.currentToken.tagName) {\n          if (isWhitespace(cp)) {\n            this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n            return;\n          }\n\n          if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n            return;\n          }\n\n          if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n\n            this.state = DATA_STATE;\n            return;\n          }\n        }\n\n        this._emitChars('</');\n\n        this._emitSeveralCodePoints(this.tempBuff);\n\n        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n      }\n    } // Script data double escape start state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {\n        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      } else if (isAsciiUpper(cp)) {\n        this.tempBuff.push(toAsciiLowerCodePoint(cp));\n\n        this._emitCodePoint(cp);\n      } else if (isAsciiLower(cp)) {\n        this.tempBuff.push(cp);\n\n        this._emitCodePoint(cp);\n      } else {\n        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n      }\n    } // Script data double escaped state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPED_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;\n\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n\n        this._emitChars('<');\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // Script data double escaped dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;\n\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n\n        this._emitChars('<');\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      }\n    } // Script data double escaped dash dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this._emitChars('-');\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n\n        this._emitChars('<');\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = SCRIPT_DATA_STATE;\n\n        this._emitChars('>');\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n        this._emitChars(unicode.REPLACEMENT_CHARACTER);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInScriptHtmlCommentLikeText);\n\n        this._emitEOFToken();\n      } else {\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      }\n    } // Script data double escaped less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.SOLIDUS) {\n        this.tempBuff = [];\n        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;\n\n        this._emitChars('/');\n      } else {\n        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);\n      }\n    } // Script data double escape end state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {\n        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n        this._emitCodePoint(cp);\n      } else if (isAsciiUpper(cp)) {\n        this.tempBuff.push(toAsciiLowerCodePoint(cp));\n\n        this._emitCodePoint(cp);\n      } else if (isAsciiLower(cp)) {\n        this.tempBuff.push(cp);\n\n        this._emitCodePoint(cp);\n      } else {\n        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);\n      }\n    } // Before attribute name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BEFORE_ATTRIBUTE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {\n        this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);\n      } else if (cp === $.EQUALS_SIGN) {\n        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);\n\n        this._createAttr('=');\n\n        this.state = ATTRIBUTE_NAME_STATE;\n      } else {\n        this._createAttr('');\n\n        this._reconsumeInState(ATTRIBUTE_NAME_STATE);\n      }\n    } // Attribute name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: ATTRIBUTE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {\n        this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);\n\n        this._unconsume();\n      } else if (cp === $.EQUALS_SIGN) {\n        this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);\n      } else if (isAsciiUpper(cp)) {\n        this.currentAttr.name += toAsciiLowerChar(cp);\n      } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {\n        this._err(ERR.unexpectedCharacterInAttributeName);\n\n        this.currentAttr.name += toChar(cp);\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;\n      } else {\n        this.currentAttr.name += toChar(cp);\n      }\n    } // After attribute name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_ATTRIBUTE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.SOLIDUS) {\n        this.state = SELF_CLOSING_START_TAG_STATE;\n      } else if (cp === $.EQUALS_SIGN) {\n        this.state = BEFORE_ATTRIBUTE_VALUE_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this._createAttr('');\n\n        this._reconsumeInState(ATTRIBUTE_NAME_STATE);\n      }\n    } // Before attribute value state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BEFORE_ATTRIBUTE_VALUE_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.QUOTATION_MARK) {\n        this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingAttributeValue);\n\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else {\n        this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);\n      }\n    } // Attribute value (double-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.QUOTATION_MARK) {\n        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;\n      } else if (cp === $.AMPERSAND) {\n        this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;\n        this.state = CHARACTER_REFERENCE_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this.currentAttr.value += toChar(cp);\n      }\n    } // Attribute value (single-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.APOSTROPHE) {\n        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;\n      } else if (cp === $.AMPERSAND) {\n        this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;\n        this.state = CHARACTER_REFERENCE_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this.currentAttr.value += toChar(cp);\n      }\n    } // Attribute value (unquoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: ATTRIBUTE_VALUE_UNQUOTED_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);\n      } else if (cp === $.AMPERSAND) {\n        this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;\n        this.state = CHARACTER_REFERENCE_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._leaveAttrValue(DATA_STATE);\n\n        this._emitCurrentToken();\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN || cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT) {\n        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);\n\n        this.currentAttr.value += toChar(cp);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this.currentAttr.value += toChar(cp);\n      }\n    } // After attribute value (quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_ATTRIBUTE_VALUE_QUOTED_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);\n      } else if (cp === $.SOLIDUS) {\n        this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._leaveAttrValue(DATA_STATE);\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingWhitespaceBetweenAttributes);\n\n        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);\n      }\n    } // Self-closing start tag state\n    //------------------------------------------------------------------\n\n  }, {\n    key: SELF_CLOSING_START_TAG_STATE,\n    value: function value(cp) {\n      if (cp === $.GREATER_THAN_SIGN) {\n        this.currentToken.selfClosing = true;\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInTag);\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.unexpectedSolidusInTag);\n\n        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);\n      }\n    } // Bogus comment state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BOGUS_COMMENT_STATE,\n    value: function value(cp) {\n      if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.data += unicode.REPLACEMENT_CHARACTER;\n      } else {\n        this.currentToken.data += toChar(cp);\n      }\n    } // Markup declaration open state\n    //------------------------------------------------------------------\n\n  }, {\n    key: MARKUP_DECLARATION_OPEN_STATE,\n    value: function value(cp) {\n      if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {\n        this._createCommentToken();\n\n        this.state = COMMENT_START_STATE;\n      } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {\n        this.state = DOCTYPE_STATE;\n      } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {\n        if (this.allowCDATA) {\n          this.state = CDATA_SECTION_STATE;\n        } else {\n          this._err(ERR.cdataInHtmlContent);\n\n          this._createCommentToken();\n\n          this.currentToken.data = '[CDATA[';\n          this.state = BOGUS_COMMENT_STATE;\n        }\n      } //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n      //results are no longer valid and we will need to start over.\n      else if (!this._ensureHibernation()) {\n        this._err(ERR.incorrectlyOpenedComment);\n\n        this._createCommentToken();\n\n        this._reconsumeInState(BOGUS_COMMENT_STATE);\n      }\n    } // Comment start state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_START_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_START_DASH_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptClosingOfEmptyComment);\n\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else {\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment start dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_START_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_END_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptClosingOfEmptyComment);\n\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInComment);\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.data += '-';\n\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_END_DASH_STATE;\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.currentToken.data += '<';\n        this.state = COMMENT_LESS_THAN_SIGN_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.data += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInComment);\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.data += toChar(cp);\n      }\n    } // Comment less-than sign state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_LESS_THAN_SIGN_STATE,\n    value: function value(cp) {\n      if (cp === $.EXCLAMATION_MARK) {\n        this.currentToken.data += '!';\n        this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;\n      } else if (cp === $.LESS_THAN_SIGN) {\n        this.currentToken.data += '!';\n      } else {\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment less-than sign bang state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_LESS_THAN_SIGN_BANG_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;\n      } else {\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment less-than sign bang dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;\n      } else {\n        this._reconsumeInState(COMMENT_END_DASH_STATE);\n      }\n    } // Comment less-than sign bang dash dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE,\n    value: function value(cp) {\n      if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {\n        this._err(ERR.nestedComment);\n      }\n\n      this._reconsumeInState(COMMENT_END_STATE);\n    } // Comment end dash state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_END_DASH_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.state = COMMENT_END_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInComment);\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.data += '-';\n\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment end state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_END_STATE,\n    value: function value(cp) {\n      if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EXCLAMATION_MARK) {\n        this.state = COMMENT_END_BANG_STATE;\n      } else if (cp === $.HYPHEN_MINUS) {\n        this.currentToken.data += '-';\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInComment);\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.data += '--';\n\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // Comment end bang state\n    //------------------------------------------------------------------\n\n  }, {\n    key: COMMENT_END_BANG_STATE,\n    value: function value(cp) {\n      if (cp === $.HYPHEN_MINUS) {\n        this.currentToken.data += '--!';\n        this.state = COMMENT_END_DASH_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.incorrectlyClosedComment);\n\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInComment);\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.data += '--!';\n\n        this._reconsumeInState(COMMENT_STATE);\n      }\n    } // DOCTYPE state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = BEFORE_DOCTYPE_NAME_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this._createDoctypeToken(null);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingWhitespaceBeforeDoctypeName);\n\n        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);\n      }\n    } // Before DOCTYPE name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BEFORE_DOCTYPE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (isAsciiUpper(cp)) {\n        this._createDoctypeToken(toAsciiLowerChar(cp));\n\n        this.state = DOCTYPE_NAME_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);\n\n        this.state = DOCTYPE_NAME_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingDoctypeName);\n\n        this._createDoctypeToken(null);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this._createDoctypeToken(null);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._createDoctypeToken(toChar(cp));\n\n        this.state = DOCTYPE_NAME_STATE;\n      }\n    } // DOCTYPE name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = AFTER_DOCTYPE_NAME_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (isAsciiUpper(cp)) {\n        this.currentToken.name += toAsciiLowerChar(cp);\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.name += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.name += toChar(cp);\n      }\n    } // After DOCTYPE name state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_DOCTYPE_NAME_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {\n        this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;\n      } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {\n        this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;\n      } //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n      //results are no longer valid and we will need to start over.\n      else if (!this._ensureHibernation()) {\n        this._err(ERR.invalidCharacterSequenceAfterDoctypeName);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // After DOCTYPE public keyword state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n      } else if (cp === $.QUOTATION_MARK) {\n        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n\n        this.currentToken.publicId = '';\n        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n\n        this.currentToken.publicId = '';\n        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // Before DOCTYPE public identifier state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.QUOTATION_MARK) {\n        this.currentToken.publicId = '';\n        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this.currentToken.publicId = '';\n        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // DOCTYPE public identifier (double-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.QUOTATION_MARK) {\n        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.publicId += toChar(cp);\n      }\n    } // DOCTYPE public identifier (single-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.APOSTROPHE) {\n        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptDoctypePublicIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.publicId += toChar(cp);\n      }\n    } // After DOCTYPE public identifier state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.QUOTATION_MARK) {\n        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // Between DOCTYPE public and system identifiers state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.GREATER_THAN_SIGN) {\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.QUOTATION_MARK) {\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // After DOCTYPE system keyword state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n      } else if (cp === $.QUOTATION_MARK) {\n        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // Before DOCTYPE system identifier state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.QUOTATION_MARK) {\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n      } else if (cp === $.APOSTROPHE) {\n        this.currentToken.systemId = '';\n        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.missingDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n        this.state = DATA_STATE;\n\n        this._emitCurrentToken();\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // DOCTYPE system identifier (double-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.QUOTATION_MARK) {\n        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.systemId += toChar(cp);\n      }\n    } // DOCTYPE system identifier (single-quoted) state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE,\n    value: function value(cp) {\n      if (cp === $.APOSTROPHE) {\n        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n\n        this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;\n      } else if (cp === $.GREATER_THAN_SIGN) {\n        this._err(ERR.abruptDoctypeSystemIdentifier);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this.currentToken.systemId += toChar(cp);\n      }\n    } // After DOCTYPE system identifier state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE,\n    value: function value(cp) {\n      if (isWhitespace(cp)) {\n        return;\n      }\n\n      if (cp === $.GREATER_THAN_SIGN) {\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInDoctype);\n\n        this.currentToken.forceQuirks = true;\n\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      } else {\n        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);\n\n        this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n      }\n    } // Bogus DOCTYPE state\n    //------------------------------------------------------------------\n\n  }, {\n    key: BOGUS_DOCTYPE_STATE,\n    value: function value(cp) {\n      if (cp === $.GREATER_THAN_SIGN) {\n        this._emitCurrentToken();\n\n        this.state = DATA_STATE;\n      } else if (cp === $.NULL) {\n        this._err(ERR.unexpectedNullCharacter);\n      } else if (cp === $.EOF) {\n        this._emitCurrentToken();\n\n        this._emitEOFToken();\n      }\n    } // CDATA section state\n    //------------------------------------------------------------------\n\n  }, {\n    key: CDATA_SECTION_STATE,\n    value: function value(cp) {\n      if (cp === $.RIGHT_SQUARE_BRACKET) {\n        this.state = CDATA_SECTION_BRACKET_STATE;\n      } else if (cp === $.EOF) {\n        this._err(ERR.eofInCdata);\n\n        this._emitEOFToken();\n      } else {\n        this._emitCodePoint(cp);\n      }\n    } // CDATA section bracket state\n    //------------------------------------------------------------------\n\n  }, {\n    key: CDATA_SECTION_BRACKET_STATE,\n    value: function value(cp) {\n      if (cp === $.RIGHT_SQUARE_BRACKET) {\n        this.state = CDATA_SECTION_END_STATE;\n      } else {\n        this._emitChars(']');\n\n        this._reconsumeInState(CDATA_SECTION_STATE);\n      }\n    } // CDATA section end state\n    //------------------------------------------------------------------\n\n  }, {\n    key: CDATA_SECTION_END_STATE,\n    value: function value(cp) {\n      if (cp === $.GREATER_THAN_SIGN) {\n        this.state = DATA_STATE;\n      } else if (cp === $.RIGHT_SQUARE_BRACKET) {\n        this._emitChars(']');\n      } else {\n        this._emitChars(']]');\n\n        this._reconsumeInState(CDATA_SECTION_STATE);\n      }\n    } // Character reference state\n    //------------------------------------------------------------------\n\n  }, {\n    key: CHARACTER_REFERENCE_STATE,\n    value: function value(cp) {\n      this.tempBuff = [$.AMPERSAND];\n\n      if (cp === $.NUMBER_SIGN) {\n        this.tempBuff.push(cp);\n        this.state = NUMERIC_CHARACTER_REFERENCE_STATE;\n      } else if (isAsciiAlphaNumeric(cp)) {\n        this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);\n      } else {\n        this._flushCodePointsConsumedAsCharacterReference();\n\n        this._reconsumeInState(this.returnState);\n      }\n    } // Named character reference state\n    //------------------------------------------------------------------\n\n  }, {\n    key: NAMED_CHARACTER_REFERENCE_STATE,\n    value: function value(cp) {\n      var matchResult = this._matchNamedCharacterReference(cp); //NOTE: matching can be abrupted by hibernation. In that case match\n      //results are no longer valid and we will need to start over.\n\n\n      if (this._ensureHibernation()) {\n        this.tempBuff = [$.AMPERSAND];\n      } else if (matchResult) {\n        var withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;\n\n        if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {\n          if (!withSemicolon) {\n            this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);\n          }\n\n          this.tempBuff = matchResult;\n        }\n\n        this._flushCodePointsConsumedAsCharacterReference();\n\n        this.state = this.returnState;\n      } else {\n        this._flushCodePointsConsumedAsCharacterReference();\n\n        this.state = AMBIGUOUS_AMPERSAND_STATE;\n      }\n    } // Ambiguos ampersand state\n    //------------------------------------------------------------------\n\n  }, {\n    key: AMBIGUOUS_AMPERSAND_STATE,\n    value: function value(cp) {\n      if (isAsciiAlphaNumeric(cp)) {\n        if (this._isCharacterReferenceInAttribute()) {\n          this.currentAttr.value += toChar(cp);\n        } else {\n          this._emitCodePoint(cp);\n        }\n      } else {\n        if (cp === $.SEMICOLON) {\n          this._err(ERR.unknownNamedCharacterReference);\n        }\n\n        this._reconsumeInState(this.returnState);\n      }\n    } // Numeric character reference state\n    //------------------------------------------------------------------\n\n  }, {\n    key: NUMERIC_CHARACTER_REFERENCE_STATE,\n    value: function value(cp) {\n      this.charRefCode = 0;\n\n      if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {\n        this.tempBuff.push(cp);\n        this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;\n      } else {\n        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);\n      }\n    } // Hexademical character reference start state\n    //------------------------------------------------------------------\n\n  }, {\n    key: HEXADEMICAL_CHARACTER_REFERENCE_START_STATE,\n    value: function value(cp) {\n      if (isAsciiHexDigit(cp)) {\n        this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);\n      } else {\n        this._err(ERR.absenceOfDigitsInNumericCharacterReference);\n\n        this._flushCodePointsConsumedAsCharacterReference();\n\n        this._reconsumeInState(this.returnState);\n      }\n    } // Decimal character reference start state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DECIMAL_CHARACTER_REFERENCE_START_STATE,\n    value: function value(cp) {\n      if (isAsciiDigit(cp)) {\n        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);\n      } else {\n        this._err(ERR.absenceOfDigitsInNumericCharacterReference);\n\n        this._flushCodePointsConsumedAsCharacterReference();\n\n        this._reconsumeInState(this.returnState);\n      }\n    } // Hexademical character reference state\n    //------------------------------------------------------------------\n\n  }, {\n    key: HEXADEMICAL_CHARACTER_REFERENCE_STATE,\n    value: function value(cp) {\n      if (isAsciiUpperHexDigit(cp)) {\n        this.charRefCode = this.charRefCode * 16 + cp - 0x37;\n      } else if (isAsciiLowerHexDigit(cp)) {\n        this.charRefCode = this.charRefCode * 16 + cp - 0x57;\n      } else if (isAsciiDigit(cp)) {\n        this.charRefCode = this.charRefCode * 16 + cp - 0x30;\n      } else if (cp === $.SEMICOLON) {\n        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;\n      } else {\n        this._err(ERR.missingSemicolonAfterCharacterReference);\n\n        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);\n      }\n    } // Decimal character reference state\n    //------------------------------------------------------------------\n\n  }, {\n    key: DECIMAL_CHARACTER_REFERENCE_STATE,\n    value: function value(cp) {\n      if (isAsciiDigit(cp)) {\n        this.charRefCode = this.charRefCode * 10 + cp - 0x30;\n      } else if (cp === $.SEMICOLON) {\n        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;\n      } else {\n        this._err(ERR.missingSemicolonAfterCharacterReference);\n\n        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);\n      }\n    } // Numeric character reference end state\n    //------------------------------------------------------------------\n\n  }, {\n    key: NUMERIC_CHARACTER_REFERENCE_END_STATE,\n    value: function value() {\n      if (this.charRefCode === $.NULL) {\n        this._err(ERR.nullCharacterReference);\n\n        this.charRefCode = $.REPLACEMENT_CHARACTER;\n      } else if (this.charRefCode > 0x10ffff) {\n        this._err(ERR.characterReferenceOutsideUnicodeRange);\n\n        this.charRefCode = $.REPLACEMENT_CHARACTER;\n      } else if (unicode.isSurrogate(this.charRefCode)) {\n        this._err(ERR.surrogateCharacterReference);\n\n        this.charRefCode = $.REPLACEMENT_CHARACTER;\n      } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {\n        this._err(ERR.noncharacterCharacterReference);\n      } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {\n        this._err(ERR.controlCharacterReference);\n\n        var replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];\n\n        if (replacement) {\n          this.charRefCode = replacement;\n        }\n      }\n\n      this.tempBuff = [this.charRefCode];\n\n      this._flushCodePointsConsumedAsCharacterReference();\n\n      this._reconsumeInState(this.returnState);\n    }\n  }]);\n\n  return Tokenizer;\n}(); //Token types\n\n\nTokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';\nTokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';\nTokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';\nTokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';\nTokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';\nTokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';\nTokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';\nTokenizer.EOF_TOKEN = 'EOF_TOKEN';\nTokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN'; //Tokenizer initial states for different modes\n\nTokenizer.MODE = {\n  DATA: DATA_STATE,\n  RCDATA: RCDATA_STATE,\n  RAWTEXT: RAWTEXT_STATE,\n  SCRIPT_DATA: SCRIPT_DATA_STATE,\n  PLAINTEXT: PLAINTEXT_STATE\n}; //Static\n\nTokenizer.getTokenAttr = function (token, attrName) {\n  for (var i = token.attrs.length - 1; i >= 0; i--) {\n    if (token.attrs[i].name === attrName) {\n      return token.attrs[i].value;\n    }\n  }\n\n  return null;\n};\n\nmodule.exports = Tokenizer;","map":null,"metadata":{},"sourceType":"module"}