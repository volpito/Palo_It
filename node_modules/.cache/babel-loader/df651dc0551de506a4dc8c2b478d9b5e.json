{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar extend = require(\"./util/core/extend\");\n\nvar functionName = require(\"@sinonjs/commons\").functionName;\n\nvar nextTick = require(\"./util/core/next-tick\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar exportAsyncBehaviors = require(\"./util/core/export-async-behaviors\");\n\nvar concat = arrayProto.concat;\nvar join = arrayProto.join;\nvar reverse = arrayProto.reverse;\nvar slice = arrayProto.slice;\nvar useLeftMostCallback = -1;\nvar useRightMostCallback = -2;\n\nfunction getCallback(behavior, args) {\n  var callArgAt = behavior.callArgAt;\n\n  if (callArgAt >= 0) {\n    return args[callArgAt];\n  }\n\n  var argumentList;\n\n  if (callArgAt === useLeftMostCallback) {\n    argumentList = args;\n  }\n\n  if (callArgAt === useRightMostCallback) {\n    argumentList = reverse(slice(args));\n  }\n\n  var callArgProp = behavior.callArgProp;\n\n  for (var i = 0, l = argumentList.length; i < l; ++i) {\n    if (!callArgProp && typeof argumentList[i] === \"function\") {\n      return argumentList[i];\n    }\n\n    if (callArgProp && argumentList[i] && typeof argumentList[i][callArgProp] === \"function\") {\n      return argumentList[i][callArgProp];\n    }\n  }\n\n  return null;\n}\n\nfunction getCallbackError(behavior, func, args) {\n  if (behavior.callArgAt < 0) {\n    var msg;\n\n    if (behavior.callArgProp) {\n      msg = \"\".concat(functionName(behavior.stub), \" expected to yield to '\").concat(valueToString(behavior.callArgProp), \"', but no object with such a property was passed.\");\n    } else {\n      msg = \"\".concat(functionName(behavior.stub), \" expected to yield, but no callback was passed.\");\n    }\n\n    if (args.length > 0) {\n      msg += \" Received [\".concat(join(args, \", \"), \"]\");\n    }\n\n    return msg;\n  }\n\n  return \"argument at index \".concat(behavior.callArgAt, \" is not a function: \").concat(func);\n}\n\nfunction ensureArgs(name, behavior, args) {\n  // map function name to internal property\n  //   callsArg => callArgAt\n  var property = name.replace(/sArg/, \"ArgAt\");\n  var index = behavior[property];\n\n  if (index >= args.length) {\n    throw new TypeError(\"\".concat(name, \" failed: \").concat(index + 1, \" arguments required but only \").concat(args.length, \" present\"));\n  }\n}\n\nfunction callCallback(behavior, args) {\n  if (typeof behavior.callArgAt === \"number\") {\n    ensureArgs(\"callsArg\", behavior, args);\n    var func = getCallback(behavior, args);\n\n    if (typeof func !== \"function\") {\n      throw new TypeError(getCallbackError(behavior, func, args));\n    }\n\n    if (behavior.callbackAsync) {\n      nextTick(function () {\n        func.apply(behavior.callbackContext, behavior.callbackArguments);\n      });\n    } else {\n      return func.apply(behavior.callbackContext, behavior.callbackArguments);\n    }\n  }\n\n  return undefined;\n}\n\nvar proto = {\n  create: function create(stub) {\n    var behavior = extend({}, proto);\n    delete behavior.create;\n    delete behavior.addBehavior;\n    delete behavior.createBehavior;\n    behavior.stub = stub;\n\n    if (stub.defaultBehavior && stub.defaultBehavior.promiseLibrary) {\n      behavior.promiseLibrary = stub.defaultBehavior.promiseLibrary;\n    }\n\n    return behavior;\n  },\n  isPresent: function isPresent() {\n    return typeof this.callArgAt === \"number\" || this.exception || this.exceptionCreator || typeof this.returnArgAt === \"number\" || this.returnThis || typeof this.resolveArgAt === \"number\" || this.resolveThis || typeof this.throwArgAt === \"number\" || this.fakeFn || this.returnValueDefined;\n  },\n\n  /*eslint complexity: [\"error\", 20]*/\n  invoke: function invoke(context, args) {\n    /*\n     * callCallback (conditionally) calls ensureArgs\n     *\n     * Note: callCallback intentionally happens before\n     * everything else and cannot be moved lower\n     */\n    var returnValue = callCallback(this, args);\n\n    if (this.exception) {\n      throw this.exception;\n    } else if (this.exceptionCreator) {\n      this.exception = this.exceptionCreator();\n      this.exceptionCreator = undefined;\n      throw this.exception;\n    } else if (typeof this.returnArgAt === \"number\") {\n      ensureArgs(\"returnsArg\", this, args);\n      return args[this.returnArgAt];\n    } else if (this.returnThis) {\n      return context;\n    } else if (typeof this.throwArgAt === \"number\") {\n      ensureArgs(\"throwsArg\", this, args);\n      throw args[this.throwArgAt];\n    } else if (this.fakeFn) {\n      return this.fakeFn.apply(context, args);\n    } else if (typeof this.resolveArgAt === \"number\") {\n      ensureArgs(\"resolvesArg\", this, args);\n      return (this.promiseLibrary || Promise).resolve(args[this.resolveArgAt]);\n    } else if (this.resolveThis) {\n      return (this.promiseLibrary || Promise).resolve(context);\n    } else if (this.resolve) {\n      return (this.promiseLibrary || Promise).resolve(this.returnValue);\n    } else if (this.reject) {\n      return (this.promiseLibrary || Promise).reject(this.returnValue);\n    } else if (this.callsThrough) {\n      var wrappedMethod = this.effectiveWrappedMethod();\n      return wrappedMethod.apply(context, args);\n    } else if (this.callsThroughWithNew) {\n      // Get the original method (assumed to be a constructor in this case)\n      var WrappedClass = this.effectiveWrappedMethod(); // Turn the arguments object into a normal array\n\n      var argsArray = slice(args); // Call the constructor\n\n      var F = WrappedClass.bind.apply(WrappedClass, concat([null], argsArray));\n      return new F();\n    } else if (typeof this.returnValue !== \"undefined\") {\n      return this.returnValue;\n    } else if (typeof this.callArgAt === \"number\") {\n      return returnValue;\n    }\n\n    return this.returnValue;\n  },\n  effectiveWrappedMethod: function effectiveWrappedMethod() {\n    for (var stubb = this.stub; stubb; stubb = stubb.parent) {\n      if (stubb.wrappedMethod) {\n        return stubb.wrappedMethod;\n      }\n    }\n\n    throw new Error(\"Unable to find wrapped method\");\n  },\n  onCall: function onCall(index) {\n    return this.stub.onCall(index);\n  },\n  onFirstCall: function onFirstCall() {\n    return this.stub.onFirstCall();\n  },\n  onSecondCall: function onSecondCall() {\n    return this.stub.onSecondCall();\n  },\n  onThirdCall: function onThirdCall() {\n    return this.stub.onThirdCall();\n  },\n  withArgs: function withArgs() {\n    throw new Error('Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" ' + 'is not supported. Use \"stub.withArgs(...).onCall(...)\" ' + \"to define sequential behavior for calls with certain arguments.\");\n  }\n};\n\nfunction createBehavior(behaviorMethod) {\n  return function () {\n    this.defaultBehavior = this.defaultBehavior || proto.create(this);\n    this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);\n    return this;\n  };\n}\n\nfunction addBehavior(stub, name, fn) {\n  proto[name] = function () {\n    fn.apply(this, concat([this], slice(arguments)));\n    return this.stub || this;\n  };\n\n  stub[name] = createBehavior(name);\n}\n\nproto.addBehavior = addBehavior;\nproto.createBehavior = createBehavior;\nvar asyncBehaviors = exportAsyncBehaviors(proto);\nmodule.exports = extend.nonEnum({}, proto, asyncBehaviors);","map":null,"metadata":{},"sourceType":"module"}