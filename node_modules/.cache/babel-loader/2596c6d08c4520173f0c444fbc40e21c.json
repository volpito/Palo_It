{"ast":null,"code":"\"use strict\";\n\nvar every = require(\"./prototypes/array\").every;\n/**\n * @private\n */\n\n\nfunction hasCallsLeft(callMap, spy) {\n  if (callMap[spy.id] === undefined) {\n    callMap[spy.id] = 0;\n  }\n\n  return callMap[spy.id] < spy.callCount;\n}\n/**\n * @private\n */\n\n\nfunction checkAdjacentCalls(callMap, spy, index, spies) {\n  var calledBeforeNext = true;\n\n  if (index !== spies.length - 1) {\n    calledBeforeNext = spy.calledBefore(spies[index + 1]);\n  }\n\n  if (hasCallsLeft(callMap, spy) && calledBeforeNext) {\n    callMap[spy.id] += 1;\n    return true;\n  }\n\n  return false;\n}\n/**\n * A Sinon proxy object (fake, spy, stub)\n *\n * @typedef {object} SinonProxy\n * @property {Function} calledBefore - A method that determines if this proxy was called before another one\n * @property {string} id - Some id\n * @property {number} callCount - Number of times this proxy has been called\n */\n\n/**\n * Returns true when the spies have been called in the order they were supplied in\n *\n * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments\n * @returns {boolean} true when spies are called in order, false otherwise\n */\n\n\nfunction calledInOrder(spies) {\n  var callMap = {}; // eslint-disable-next-line no-underscore-dangle\n\n  var _spies = arguments.length > 1 ? arguments : spies;\n\n  return every(_spies, checkAdjacentCalls.bind(null, callMap));\n}\n\nmodule.exports = calledInOrder;","map":null,"metadata":{},"sourceType":"module"}