{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar behavior = require(\"./behavior\");\n\nvar behaviors = require(\"./default-behaviors\");\n\nvar createProxy = require(\"./proxy\");\n\nvar functionName = require(\"@sinonjs/commons\").functionName;\n\nvar hasOwnProperty = require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n\nvar isNonExistentProperty = require(\"./util/core/is-non-existent-property\");\n\nvar spy = require(\"./spy\");\n\nvar extend = require(\"./util/core/extend\");\n\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n\nvar isEsModule = require(\"./util/core/is-es-module\");\n\nvar wrapMethod = require(\"./util/core/wrap-method\");\n\nvar throwOnFalsyObject = require(\"./throw-on-falsy-object\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar walkObject = require(\"./util/core/walk-object\");\n\nvar forEach = arrayProto.forEach;\nvar pop = arrayProto.pop;\nvar slice = arrayProto.slice;\nvar sort = arrayProto.sort;\nvar uuid = 0;\n\nfunction createStub(originalFunc) {\n  var proxy;\n\n  function functionStub() {\n    var args = slice(arguments);\n    var matchings = proxy.matchingFakes(args);\n    var fnStub = pop(sort(matchings, function (a, b) {\n      return a.matchingArguments.length - b.matchingArguments.length;\n    })) || proxy;\n    return getCurrentBehavior(fnStub).invoke(this, arguments);\n  }\n\n  proxy = createProxy(functionStub, originalFunc || functionStub); // Inherit spy API:\n\n  extend.nonEnum(proxy, spy); // Inherit stub API:\n\n  extend.nonEnum(proxy, stub);\n  var name = originalFunc ? functionName(originalFunc) : null;\n  extend.nonEnum(proxy, {\n    fakes: [],\n    instantiateFake: createStub,\n    displayName: name || \"stub\",\n    defaultBehavior: null,\n    behaviors: [],\n    id: \"stub#\".concat(uuid++)\n  });\n  return proxy;\n}\n\nfunction stub(object, property) {\n  if (arguments.length > 2) {\n    throw new TypeError(\"stub(obj, 'meth', fn) has been removed, see documentation\");\n  }\n\n  if (isEsModule(object)) {\n    throw new TypeError(\"ES Modules cannot be stubbed\");\n  }\n\n  throwOnFalsyObject.apply(null, arguments);\n\n  if (isNonExistentProperty(object, property)) {\n    throw new TypeError(\"Cannot stub non-existent property \".concat(valueToString(property)));\n  }\n\n  var actualDescriptor = getPropertyDescriptor(object, property);\n  var isObjectOrFunction = _typeof(object) === \"object\" || typeof object === \"function\";\n  var isStubbingEntireObject = typeof property === \"undefined\" && isObjectOrFunction;\n  var isCreatingNewStub = !object && typeof property === \"undefined\";\n  var isStubbingNonFuncProperty = isObjectOrFunction && typeof property !== \"undefined\" && (typeof actualDescriptor === \"undefined\" || typeof actualDescriptor.value !== \"function\");\n\n  if (isStubbingEntireObject) {\n    return walkObject(stub, object);\n  }\n\n  if (isCreatingNewStub) {\n    return createStub();\n  }\n\n  var func = typeof actualDescriptor.value === \"function\" ? actualDescriptor.value : null;\n  var s = createStub(func);\n  extend.nonEnum(s, {\n    rootObj: object,\n    propName: property,\n    shadowsPropOnPrototype: !actualDescriptor.isOwn,\n    restore: function restore() {\n      if (actualDescriptor !== undefined && actualDescriptor.isOwn) {\n        Object.defineProperty(object, property, actualDescriptor);\n        return;\n      }\n\n      delete object[property];\n    }\n  });\n  return isStubbingNonFuncProperty ? s : wrapMethod(object, property, s);\n}\n\nstub.createStubInstance = function (constructor, overrides) {\n  if (typeof constructor !== \"function\") {\n    throw new TypeError(\"The constructor should be a function.\");\n  }\n\n  var stubbedObject = stub(Object.create(constructor.prototype));\n  forEach(Object.keys(overrides || {}), function (propertyName) {\n    if (propertyName in stubbedObject) {\n      var value = overrides[propertyName];\n\n      if (value && value.createStubInstance) {\n        stubbedObject[propertyName] = value;\n      } else {\n        stubbedObject[propertyName].returns(value);\n      }\n    } else {\n      throw new Error(\"Cannot stub \".concat(propertyName, \". Property does not exist!\"));\n    }\n  });\n  return stubbedObject;\n};\n/*eslint-disable no-use-before-define*/\n\n\nfunction getParentBehaviour(stubInstance) {\n  return stubInstance.parent && getCurrentBehavior(stubInstance.parent);\n}\n\nfunction getDefaultBehavior(stubInstance) {\n  return stubInstance.defaultBehavior || getParentBehaviour(stubInstance) || behavior.create(stubInstance);\n}\n\nfunction getCurrentBehavior(stubInstance) {\n  var currentBehavior = stubInstance.behaviors[stubInstance.callCount - 1];\n  return currentBehavior && currentBehavior.isPresent() ? currentBehavior : getDefaultBehavior(stubInstance);\n}\n/*eslint-enable no-use-before-define*/\n\n\nvar proto = {\n  resetBehavior: function resetBehavior() {\n    this.defaultBehavior = null;\n    this.behaviors = [];\n    delete this.returnValue;\n    delete this.returnArgAt;\n    delete this.throwArgAt;\n    delete this.resolveArgAt;\n    delete this.fakeFn;\n    this.returnThis = false;\n    this.resolveThis = false;\n    forEach(this.fakes, function (fake) {\n      fake.resetBehavior();\n    });\n  },\n  reset: function reset() {\n    this.resetHistory();\n    this.resetBehavior();\n  },\n  onCall: function onCall(index) {\n    if (!this.behaviors[index]) {\n      this.behaviors[index] = behavior.create(this);\n    }\n\n    return this.behaviors[index];\n  },\n  onFirstCall: function onFirstCall() {\n    return this.onCall(0);\n  },\n  onSecondCall: function onSecondCall() {\n    return this.onCall(1);\n  },\n  onThirdCall: function onThirdCall() {\n    return this.onCall(2);\n  },\n  withArgs: function withArgs() {\n    var fake = spy.withArgs.apply(this, arguments);\n\n    if (this.defaultBehavior && this.defaultBehavior.promiseLibrary) {\n      fake.defaultBehavior = fake.defaultBehavior || behavior.create(fake);\n      fake.defaultBehavior.promiseLibrary = this.defaultBehavior.promiseLibrary;\n    }\n\n    return fake;\n  }\n};\nforEach(Object.keys(behavior), function (method) {\n  if (hasOwnProperty(behavior, method) && !hasOwnProperty(proto, method) && method !== \"create\" && method !== \"invoke\") {\n    proto[method] = behavior.createBehavior(method);\n  }\n});\nforEach(Object.keys(behaviors), function (method) {\n  if (hasOwnProperty(behaviors, method) && !hasOwnProperty(proto, method)) {\n    behavior.addBehavior(stub, method, behaviors[method]);\n  }\n});\nextend(stub, proto);\nmodule.exports = stub;","map":null,"metadata":{},"sourceType":"module"}