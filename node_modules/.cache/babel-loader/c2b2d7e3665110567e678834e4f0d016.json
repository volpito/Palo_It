{"ast":null,"code":"\"use strict\";\n\nvar fake = require(\"./fake\");\n\nvar isRestorable = require(\"./util/core/is-restorable\");\n\nvar STATUS_PENDING = \"pending\";\nvar STATUS_RESOLVED = \"resolved\";\nvar STATUS_REJECTED = \"rejected\";\n/**\n * Returns a fake for a given function or undefined. If no functino is given, a\n * new fake is returned. If the given function is already a fake, it is\n * returned as is. Otherwise the given function is wrapped in a new fake.\n *\n * @param {Function} [executor] The optional executor function.\n * @returns {Function}\n */\n\nfunction getFakeExecutor(executor) {\n  if (isRestorable(executor)) {\n    return executor;\n  }\n\n  if (executor) {\n    return fake(executor);\n  }\n\n  return fake();\n}\n/**\n * Returns a new promise that exposes it's internal `status`, `resolvedValue`\n * and `rejectedValue` and can be resolved or rejected from the outside by\n * calling `resolve(value)` or `reject(reason)`.\n *\n * @param {Function} [executor] The optional executor function.\n * @returns {Promise}\n */\n\n\nfunction promise(executor) {\n  var fakeExecutor = getFakeExecutor(executor);\n  var sinonPromise = new Promise(fakeExecutor);\n  sinonPromise.status = STATUS_PENDING;\n  sinonPromise.then(function (value) {\n    sinonPromise.status = STATUS_RESOLVED;\n    sinonPromise.resolvedValue = value;\n  }).catch(function (reason) {\n    sinonPromise.status = STATUS_REJECTED;\n    sinonPromise.rejectedValue = reason;\n  });\n  /**\n   * Resolves or rejects the promise with the given status and value.\n   *\n   * @param {string} status\n   * @param {*} value\n   * @param {Function} callback\n   */\n\n  function finalize(status, value, callback) {\n    if (sinonPromise.status !== STATUS_PENDING) {\n      throw new Error(\"Promise already \".concat(sinonPromise.status));\n    }\n\n    sinonPromise.status = status;\n    callback(value);\n  }\n\n  sinonPromise.resolve = function (value) {\n    finalize(STATUS_RESOLVED, value, fakeExecutor.firstCall.args[0]); // Return the promise so that callers can await it:\n\n    return sinonPromise;\n  };\n\n  sinonPromise.reject = function (reason) {\n    finalize(STATUS_REJECTED, reason, fakeExecutor.firstCall.args[1]); // Return a new promise that resolves when the sinon promise was\n    // rejected, so that callers can await it:\n\n    return new Promise(function (resolve) {\n      sinonPromise.catch(function () {\n        return resolve();\n      });\n    });\n  };\n\n  return sinonPromise;\n}\n\nmodule.exports = promise;","map":null,"metadata":{},"sourceType":"module"}