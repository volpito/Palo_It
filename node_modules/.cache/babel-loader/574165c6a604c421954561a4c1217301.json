{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar globalObject = require(\"@sinonjs/commons\").global;\n/**\n * @typedef {object} Clock\n * @property {number} now\n * @property {any} timeouts\n * @property {typeof globalThis.Date} Date\n * @property {number} loopLimit\n * @property {(func: Function, timeout: number) => number} requestIdleCallback\n * @property {(timerId: number) => void} cancelIdleCallback\n * @property {setTimeout} setTimeout\n * @property {clearTimeout} clearTimeout\n * @property {(func: Function, ...args: any[]) => void} nextTick\n * @property {queueMicrotask} queueMicrotask\n * @property {setInterval} setInterval\n * @property {clearInterval} clearInterval\n * @property {(func: (...args: any[]) => void, ...args: any[]) => NodeTimer} setImmediate\n * @property {(timerId: NodeTimer) => void} clearImmediate\n * @property {() => number} countTimers\n * @property {(func: (timer: number) => void) => number} requestAnimationFrame\n * @property {(timerId: number) => void} cancelAnimationFrame\n * @property {() => void} runMicrotasks\n * @property {(tickValue: string | number) => number} tick\n * @property {(tickValue: string | number) => Promise<number>} tickAsync\n * @property {() => number} next\n * @property {() => Promise<number>} nextAsync\n * @property {() => number} runAll\n * @property {() => number} runToFrame\n * @property {() => Promise<number>} runAllAsync\n * @property {() => number} runToLast\n * @property {() => Promise<number>} runToLastAsync\n * @property {() => void} reset\n * @property {(systemTime: number | Date) => void} setSystemTime\n * @property {({now(): number})} performance\n * @property {(prev: any) => number[]} hrTime\n * @property {() => void} uninstall Uninstall the clock.\n * @property {any} methods\n */\n\n/**\n * Configuration object for the `install` method.\n *\n * @typedef {object} Config\n * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n * @property {string[]} [toFake] names of the methods that should be faked.\n * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n */\n\n/**\n * @typedef {object} NodeTimer\n * @property {() => boolean} hasRef\n * @property {() => any} ref\n * @property {() => any} unref\n */\n\n/* eslint-disable complexity */\n\n/**\n * Mocks available features in the specified global namespace.\n *\n * @param {*} _global Namespace to mock (e.g. `window`)\n */\n\n\nfunction withGlobal(_global) {\n  var userAgent = _global.navigator && _global.navigator.userAgent;\n  var isRunningInIE = userAgent && userAgent.indexOf(\"MSIE \") > -1;\n  var maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n\n  var NOOP = function NOOP() {\n    return undefined;\n  };\n\n  var NOOP_ARRAY = function NOOP_ARRAY() {\n    return [];\n  };\n\n  var timeoutResult = _global.setTimeout(NOOP, 0);\n\n  var addTimerReturnsObject = _typeof(timeoutResult) === \"object\";\n  var hrtimePresent = _global.process && typeof _global.process.hrtime === \"function\";\n  var hrtimeBigintPresent = hrtimePresent && typeof _global.process.hrtime.bigint === \"function\";\n  var nextTickPresent = _global.process && typeof _global.process.nextTick === \"function\";\n\n  var utilPromisify = _global.process && require(\"util\").promisify;\n\n  var performancePresent = _global.performance && typeof _global.performance.now === \"function\";\n\n  var hasPerformancePrototype = _global.Performance && _typeof(_global.Performance).match(/^(function|object)$/);\n\n  var queueMicrotaskPresent = _global.hasOwnProperty(\"queueMicrotask\");\n\n  var requestAnimationFramePresent = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === \"function\";\n  var cancelAnimationFramePresent = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === \"function\";\n  var requestIdleCallbackPresent = _global.requestIdleCallback && typeof _global.requestIdleCallback === \"function\";\n  var cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === \"function\";\n  var setImmediatePresent = _global.setImmediate && typeof _global.setImmediate === \"function\"; // Make properties writable in IE, as per\n  // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n\n  /* eslint-disable no-self-assign */\n\n  if (isRunningInIE) {\n    _global.setTimeout = _global.setTimeout;\n    _global.clearTimeout = _global.clearTimeout;\n    _global.setInterval = _global.setInterval;\n    _global.clearInterval = _global.clearInterval;\n    _global.Date = _global.Date;\n  } // setImmediate is not a standard function\n  // avoid adding the prop to the window object if not present\n\n\n  if (setImmediatePresent) {\n    _global.setImmediate = _global.setImmediate;\n    _global.clearImmediate = _global.clearImmediate;\n  }\n  /* eslint-enable no-self-assign */\n\n\n  _global.clearTimeout(timeoutResult);\n\n  var NativeDate = _global.Date;\n  var uniqueTimerId = 1;\n\n  function isNumberFinite(num) {\n    if (Number.isFinite) {\n      return Number.isFinite(num);\n    }\n\n    return isFinite(num);\n  }\n  /**\n   * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n   * number of milliseconds. This is used to support human-readable strings passed\n   * to clock.tick()\n   */\n\n\n  function parseTime(str) {\n    if (!str) {\n      return 0;\n    }\n\n    var strings = str.split(\":\");\n    var l = strings.length;\n    var i = l;\n    var ms = 0;\n    var parsed;\n\n    if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n      throw new Error(\"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\");\n    }\n\n    while (i--) {\n      parsed = parseInt(strings[i], 10);\n\n      if (parsed >= 60) {\n        throw new Error(\"Invalid time \" + str);\n      }\n\n      ms += parsed * Math.pow(60, l - i - 1);\n    }\n\n    return ms * 1000;\n  }\n  /**\n   * Get the decimal part of the millisecond value as nanoseconds\n   *\n   * @param {number} msFloat the number of milliseconds\n   * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n   *\n   * Example: nanoRemainer(123.456789) -> 456789\n   */\n\n\n  function nanoRemainder(msFloat) {\n    var modulo = 1e6;\n    var remainder = msFloat * 1e6 % modulo;\n    var positiveRemainder = remainder < 0 ? remainder + modulo : remainder;\n    return Math.floor(positiveRemainder);\n  }\n  /**\n   * Used to grok the `now` parameter to createClock.\n   * @param {Date|number} epoch the system time\n   */\n\n\n  function getEpoch(epoch) {\n    if (!epoch) {\n      return 0;\n    }\n\n    if (typeof epoch.getTime === \"function\") {\n      return epoch.getTime();\n    }\n\n    if (typeof epoch === \"number\") {\n      return epoch;\n    }\n\n    throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n  }\n\n  function inRange(from, to, timer) {\n    return timer && timer.callAt >= from && timer.callAt <= to;\n  }\n\n  function mirrorDateProperties(target, source) {\n    var prop;\n\n    for (prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        target[prop] = source[prop];\n      }\n    } // set special now implementation\n\n\n    if (source.now) {\n      target.now = function now() {\n        return target.clock.now;\n      };\n    } else {\n      delete target.now;\n    } // set special toSource implementation\n\n\n    if (source.toSource) {\n      target.toSource = function toSource() {\n        return source.toSource();\n      };\n    } else {\n      delete target.toSource;\n    } // set special toString implementation\n\n\n    target.toString = function toString() {\n      return source.toString();\n    };\n\n    target.prototype = source.prototype;\n    target.parse = source.parse;\n    target.UTC = source.UTC;\n    target.prototype.toUTCString = source.prototype.toUTCString;\n    return target;\n  }\n\n  function createDate() {\n    function ClockDate(year, month, date, hour, minute, second, ms) {\n      // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n      // This remains so in the 10th edition of 2019 as well.\n      if (!(this instanceof ClockDate)) {\n        return new NativeDate(ClockDate.clock.now).toString();\n      } // if Date is called as a constructor with 'new' keyword\n      // Defensive and verbose to avoid potential harm in passing\n      // explicit undefined when user does not pass argument\n\n\n      switch (arguments.length) {\n        case 0:\n          return new NativeDate(ClockDate.clock.now);\n\n        case 1:\n          return new NativeDate(year);\n\n        case 2:\n          return new NativeDate(year, month);\n\n        case 3:\n          return new NativeDate(year, month, date);\n\n        case 4:\n          return new NativeDate(year, month, date, hour);\n\n        case 5:\n          return new NativeDate(year, month, date, hour, minute);\n\n        case 6:\n          return new NativeDate(year, month, date, hour, minute, second);\n\n        default:\n          return new NativeDate(year, month, date, hour, minute, second, ms);\n      }\n    }\n\n    return mirrorDateProperties(ClockDate, NativeDate);\n  }\n\n  function enqueueJob(clock, job) {\n    // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n    if (!clock.jobs) {\n      clock.jobs = [];\n    }\n\n    clock.jobs.push(job);\n  }\n\n  function runJobs(clock) {\n    // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n    if (!clock.jobs) {\n      return;\n    }\n\n    for (var i = 0; i < clock.jobs.length; i++) {\n      var job = clock.jobs[i];\n      job.func.apply(null, job.args);\n\n      if (clock.loopLimit && i > clock.loopLimit) {\n        throw new Error(\"Aborting after running \" + clock.loopLimit + \" timers, assuming an infinite loop!\");\n      }\n    }\n\n    clock.jobs = [];\n  }\n\n  function addTimer(clock, timer) {\n    if (timer.func === undefined) {\n      throw new Error(\"Callback must be provided to timer calls\");\n    }\n\n    if (addTimerReturnsObject) {\n      // Node.js environment\n      if (typeof timer.func !== \"function\") {\n        throw new TypeError(\"[ERR_INVALID_CALLBACK]: Callback must be a function. Received \" + timer.func + \" of type \" + _typeof(timer.func));\n      }\n    }\n\n    timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n    if (timer.hasOwnProperty(\"delay\")) {\n      if (typeof timer.delay !== \"number\") {\n        timer.delay = parseInt(timer.delay, 10);\n      }\n\n      if (!isNumberFinite(timer.delay)) {\n        timer.delay = 0;\n      }\n\n      timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n      timer.delay = Math.max(0, timer.delay);\n    }\n\n    if (timer.hasOwnProperty(\"interval\")) {\n      timer.type = \"Interval\";\n      timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n    }\n\n    if (timer.hasOwnProperty(\"animation\")) {\n      timer.type = \"AnimationFrame\";\n      timer.animation = true;\n    }\n\n    if (!clock.timers) {\n      clock.timers = {};\n    }\n\n    timer.id = uniqueTimerId++;\n    timer.createdAt = clock.now;\n    timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n    clock.timers[timer.id] = timer;\n\n    if (addTimerReturnsObject) {\n      var res = {\n        id: timer.id,\n        ref: function ref() {\n          return res;\n        },\n        unref: function unref() {\n          return res;\n        },\n        refresh: function refresh() {\n          clearTimeout(timer.id);\n          var args = [timer.func, timer.delay].concat(timer.args);\n          return setTimeout.apply(null, args);\n        }\n      };\n      return res;\n    }\n\n    return timer.id;\n  }\n  /* eslint consistent-return: \"off\" */\n\n\n  function compareTimers(a, b) {\n    // Sort first by absolute timing\n    if (a.callAt < b.callAt) {\n      return -1;\n    }\n\n    if (a.callAt > b.callAt) {\n      return 1;\n    } // Sort next by immediate, immediate timers take precedence\n\n\n    if (a.immediate && !b.immediate) {\n      return -1;\n    }\n\n    if (!a.immediate && b.immediate) {\n      return 1;\n    } // Sort next by creation time, earlier-created timers take precedence\n\n\n    if (a.createdAt < b.createdAt) {\n      return -1;\n    }\n\n    if (a.createdAt > b.createdAt) {\n      return 1;\n    } // Sort next by id, lower-id timers take precedence\n\n\n    if (a.id < b.id) {\n      return -1;\n    }\n\n    if (a.id > b.id) {\n      return 1;\n    } // As timer ids are unique, no fallback `0` is necessary\n\n  }\n\n  function firstTimerInRange(clock, from, to) {\n    var timers = clock.timers;\n    var timer = null;\n    var id, isInRange;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        isInRange = inRange(from, to, timers[id]);\n\n        if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n\n  function firstTimer(clock) {\n    var timers = clock.timers;\n    var timer = null;\n    var id;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === 1) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n\n  function lastTimer(clock) {\n    var timers = clock.timers;\n    var timer = null;\n    var id;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === -1) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n\n  function callTimer(clock, timer) {\n    if (typeof timer.interval === \"number\") {\n      clock.timers[timer.id].callAt += timer.interval;\n    } else {\n      delete clock.timers[timer.id];\n    }\n\n    if (typeof timer.func === \"function\") {\n      timer.func.apply(null, timer.args);\n    } else {\n      /* eslint no-eval: \"off\" */\n      var eval2 = eval;\n\n      (function () {\n        eval2(timer.func);\n      })();\n    }\n  }\n\n  function clearTimer(clock, timerId, ttype) {\n    if (!timerId) {\n      // null appears to be allowed in most browsers, and appears to be\n      // relied upon by some libraries, like Bootstrap carousel\n      return;\n    }\n\n    if (!clock.timers) {\n      clock.timers = {};\n    } // in Node, timerId is an object with .ref()/.unref(), and\n    // its .id field is the actual timer id.\n\n\n    var id = _typeof(timerId) === \"object\" ? timerId.id : timerId;\n\n    if (clock.timers.hasOwnProperty(id)) {\n      // check that the ID matches a timer of the correct type\n      var timer = clock.timers[id];\n\n      if (timer.type === ttype || timer.type === \"Timeout\" && ttype === \"Interval\" || timer.type === \"Interval\" && ttype === \"Timeout\") {\n        delete clock.timers[id];\n      } else {\n        var clear = ttype === \"AnimationFrame\" ? \"cancelAnimationFrame\" : \"clear\" + ttype;\n        var schedule = timer.type === \"AnimationFrame\" ? \"requestAnimationFrame\" : \"set\" + timer.type;\n        throw new Error(\"Cannot clear timer: timer created with \" + schedule + \"() but cleared with \" + clear + \"()\");\n      }\n    }\n  }\n\n  function uninstall(clock, config) {\n    var method, i, l;\n    var installedHrTime = \"_hrtime\";\n    var installedNextTick = \"_nextTick\";\n\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      method = clock.methods[i];\n\n      if (method === \"hrtime\" && _global.process) {\n        _global.process.hrtime = clock[installedHrTime];\n      } else if (method === \"nextTick\" && _global.process) {\n        _global.process.nextTick = clock[installedNextTick];\n      } else if (method === \"performance\") {\n        var originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, \"_\" + method);\n\n        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n          Object.defineProperty(_global, method, originalPerfDescriptor);\n        } else if (originalPerfDescriptor.configurable) {\n          _global[method] = clock[\"_\" + method];\n        }\n      } else {\n        if (_global[method] && _global[method].hadOwnProperty) {\n          _global[method] = clock[\"_\" + method];\n\n          if (method === \"clearInterval\" && config.shouldAdvanceTime === true) {\n            _global[method](clock.attachedInterval);\n          }\n        } else {\n          try {\n            delete _global[method];\n          } catch (ignore) {\n            /* eslint no-empty: \"off\" */\n          }\n        }\n      }\n    } // Prevent multiple executions which will completely remove these props\n\n\n    clock.methods = []; // return pending timers, to enable checking what timers remained on uninstall\n\n    if (!clock.timers) {\n      return [];\n    }\n\n    return Object.keys(clock.timers).map(function mapper(key) {\n      return clock.timers[key];\n    });\n  }\n\n  function hijackMethod(target, method, clock) {\n    clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);\n    clock[\"_\" + method] = target[method];\n\n    if (method === \"Date\") {\n      var date = mirrorDateProperties(clock[method], target[method]);\n      target[method] = date;\n    } else if (method === \"performance\") {\n      var originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method); // JSDOM has a read only performance field so we have to save/copy it differently\n\n      if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n        Object.defineProperty(clock, \"_\" + method, originalPerfDescriptor);\n        var perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);\n        Object.defineProperty(target, method, perfDescriptor);\n      } else {\n        target[method] = clock[method];\n      }\n    } else {\n      target[method] = function () {\n        return clock[method].apply(clock, arguments);\n      };\n\n      Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));\n    }\n\n    target[method].clock = clock;\n  }\n\n  function doIntervalTick(clock, advanceTimeDelta) {\n    clock.tick(advanceTimeDelta);\n  }\n  /**\n   * @typedef {object} Timers\n   * @property {setTimeout} setTimeout\n   * @property {clearTimeout} clearTimeout\n   * @property {setInterval} setInterval\n   * @property {clearInterval} clearInterval\n   * @property {typeof globalThis.Date} Date\n   * @property {((fn: (...args: any[]) => void, ...args: any[]) => NodeTimer)=} setImmediate\n   * @property {((id: NodeTimer) => void)=} clearImmediate\n   * @property {((time?: [number, number]) => [number, number])=} hrtime\n   * @property {((fn: Function, ...args: any[]) => void)=} nextTick\n   * @property {({now(): number})=} performance\n   * @property {((fn: (timer: number) => void) => number)=} requestAnimationFrame\n   * @property {boolean=} queueMicrotask\n   * @property {((id: number) => void)=} cancelAnimationFrame\n   * @property {((fn: (deadline: any) => void, options?: any) => number)=} requestIdleCallback\n   * @property {((id: number) => void)=} cancelIdleCallback\n   */\n\n  /** @type {Timers} */\n\n\n  var timers = {\n    setTimeout: _global.setTimeout,\n    clearTimeout: _global.clearTimeout,\n    setInterval: _global.setInterval,\n    clearInterval: _global.clearInterval,\n    Date: _global.Date\n  };\n\n  if (setImmediatePresent) {\n    timers.setImmediate = _global.setImmediate;\n    timers.clearImmediate = _global.clearImmediate;\n  }\n\n  if (hrtimePresent) {\n    timers.hrtime = _global.process.hrtime;\n  }\n\n  if (nextTickPresent) {\n    timers.nextTick = _global.process.nextTick;\n  }\n\n  if (performancePresent) {\n    timers.performance = _global.performance;\n  }\n\n  if (requestAnimationFramePresent) {\n    timers.requestAnimationFrame = _global.requestAnimationFrame;\n  }\n\n  if (queueMicrotaskPresent) {\n    timers.queueMicrotask = true;\n  }\n\n  if (cancelAnimationFramePresent) {\n    timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n  }\n\n  if (requestIdleCallbackPresent) {\n    timers.requestIdleCallback = _global.requestIdleCallback;\n  }\n\n  if (cancelIdleCallbackPresent) {\n    timers.cancelIdleCallback = _global.cancelIdleCallback;\n  }\n\n  var originalSetTimeout = _global.setImmediate || _global.setTimeout;\n  /**\n   * @param {Date|number} [start] the system time - non-integer values are floored\n   * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n   * @returns {Clock}\n   */\n\n  function createClock(start, loopLimit) {\n    // eslint-disable-next-line no-param-reassign\n    start = Math.floor(getEpoch(start)); // eslint-disable-next-line no-param-reassign\n\n    loopLimit = loopLimit || 1000;\n    var nanos = 0;\n    var adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n    if (NativeDate === undefined) {\n      throw new Error(\"The global scope doesn't have a `Date` object\" + \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\");\n    }\n\n    var clock = {\n      now: start,\n      timeouts: {},\n      Date: createDate(),\n      loopLimit: loopLimit\n    };\n    clock.Date.clock = clock;\n\n    function getTimeToNextFrame() {\n      return 16 - (clock.now - start) % 16;\n    }\n\n    function hrtime(prev) {\n      var millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n      var secsSinceStart = Math.floor(millisSinceStart / 1000);\n      var remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];\n\n      if (Array.isArray(prev)) {\n        if (prev[1] > 1e9) {\n          throw new TypeError(\"Number of nanoseconds can't exceed a billion\");\n        }\n\n        var oldSecs = prev[0];\n        var nanoDiff = remainderInNanos - prev[1];\n        var secDiff = secsSinceStart - oldSecs;\n\n        if (nanoDiff < 0) {\n          nanoDiff += 1e9;\n          secDiff -= 1;\n        }\n\n        return [secDiff, nanoDiff];\n      }\n\n      return [secsSinceStart, remainderInNanos];\n    }\n\n    if (hrtimeBigintPresent) {\n      hrtime.bigint = function () {\n        var parts = hrtime();\n        return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n      };\n    }\n\n    clock.requestIdleCallback = function requestIdleCallback(func, timeout) {\n      var timeToNextIdlePeriod = 0;\n\n      if (clock.countTimers() > 0) {\n        timeToNextIdlePeriod = 50; // const for now\n      }\n\n      var result = addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: typeof timeout === \"undefined\" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod)\n      });\n      return result.id || result;\n    };\n\n    clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n      return clearTimer(clock, timerId, \"Timeout\");\n    };\n\n    clock.setTimeout = function setTimeout(func, timeout) {\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout\n      });\n    };\n\n    if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n      clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {\n        return new _global.Promise(function setTimeoutExecutor(resolve) {\n          addTimer(clock, {\n            func: resolve,\n            args: [arg],\n            delay: timeout\n          });\n        });\n      };\n    }\n\n    clock.clearTimeout = function clearTimeout(timerId) {\n      return clearTimer(clock, timerId, \"Timeout\");\n    };\n\n    clock.nextTick = function nextTick(func) {\n      return enqueueJob(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 1)\n      });\n    };\n\n    clock.queueMicrotask = function queueMicrotask(func) {\n      return clock.nextTick(func); // explicitly drop additional arguments\n    };\n\n    clock.setInterval = function setInterval(func, timeout) {\n      // eslint-disable-next-line no-param-reassign\n      timeout = parseInt(timeout, 10);\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout,\n        interval: timeout\n      });\n    };\n\n    clock.clearInterval = function clearInterval(timerId) {\n      return clearTimer(clock, timerId, \"Interval\");\n    };\n\n    if (setImmediatePresent) {\n      clock.setImmediate = function setImmediate(func) {\n        return addTimer(clock, {\n          func: func,\n          args: Array.prototype.slice.call(arguments, 1),\n          immediate: true\n        });\n      };\n\n      if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n        clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {\n          return new _global.Promise(function setImmediateExecutor(resolve) {\n            addTimer(clock, {\n              func: resolve,\n              args: [arg],\n              immediate: true\n            });\n          });\n        };\n      }\n\n      clock.clearImmediate = function clearImmediate(timerId) {\n        return clearTimer(clock, timerId, \"Immediate\");\n      };\n    }\n\n    clock.countTimers = function countTimers() {\n      return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;\n    };\n\n    clock.requestAnimationFrame = function requestAnimationFrame(func) {\n      var result = addTimer(clock, {\n        func: func,\n        delay: getTimeToNextFrame(),\n        args: [clock.now + getTimeToNextFrame()],\n        animation: true\n      });\n      return result.id || result;\n    };\n\n    clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n      return clearTimer(clock, timerId, \"AnimationFrame\");\n    };\n\n    clock.runMicrotasks = function runMicrotasks() {\n      runJobs(clock);\n    };\n\n    function doTick(tickValue, isAsync, resolve, reject) {\n      var msFloat = typeof tickValue === \"number\" ? tickValue : parseTime(tickValue);\n      var ms = Math.floor(msFloat);\n      var remainder = nanoRemainder(msFloat);\n      var nanosTotal = nanos + remainder;\n      var tickTo = clock.now + ms;\n\n      if (msFloat < 0) {\n        throw new TypeError(\"Negative ticks are not supported\");\n      } // adjust for positive overflow\n\n\n      if (nanosTotal >= 1e6) {\n        tickTo += 1;\n        nanosTotal -= 1e6;\n      }\n\n      nanos = nanosTotal;\n      var tickFrom = clock.now;\n      var previous = clock.now;\n      var timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;\n      clock.duringTick = true; // perform microtasks\n\n      oldNow = clock.now;\n      runJobs(clock);\n\n      if (oldNow !== clock.now) {\n        // compensate for any setSystemTime() call during microtask callback\n        tickFrom += clock.now - oldNow;\n        tickTo += clock.now - oldNow;\n      }\n\n      function doTickInner() {\n        // perform each timer in the requested range\n        timer = firstTimerInRange(clock, tickFrom, tickTo); // eslint-disable-next-line no-unmodified-loop-condition\n\n        while (timer && tickFrom <= tickTo) {\n          if (clock.timers[timer.id]) {\n            tickFrom = timer.callAt;\n            clock.now = timer.callAt;\n            oldNow = clock.now;\n\n            try {\n              runJobs(clock);\n              callTimer(clock, timer);\n            } catch (e) {\n              firstException = firstException || e;\n            }\n\n            if (isAsync) {\n              // finish up after native setImmediate callback to allow\n              // all native es6 promises to process their callbacks after\n              // each timer fires.\n              originalSetTimeout(nextPromiseTick);\n              return;\n            }\n\n            compensationCheck();\n          }\n\n          postTimerCall();\n        } // perform process.nextTick()s again\n\n\n        oldNow = clock.now;\n        runJobs(clock);\n\n        if (oldNow !== clock.now) {\n          // compensate for any setSystemTime() call during process.nextTick() callback\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n        }\n\n        clock.duringTick = false; // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n\n        timer = firstTimerInRange(clock, tickFrom, tickTo);\n\n        if (timer) {\n          try {\n            clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n          } catch (e) {\n            firstException = firstException || e;\n          }\n        } else {\n          // no timers remaining in the requested range: move the clock all the way to the end\n          clock.now = tickTo; // update nanos\n\n          nanos = nanosTotal;\n        }\n\n        if (firstException) {\n          throw firstException;\n        }\n\n        if (isAsync) {\n          resolve(clock.now);\n        } else {\n          return clock.now;\n        }\n      }\n\n      nextPromiseTick = isAsync && function () {\n        try {\n          compensationCheck();\n          postTimerCall();\n          doTickInner();\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      compensationCheck = function compensationCheck() {\n        // compensate for any setSystemTime() call during timer callback\n        if (oldNow !== clock.now) {\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n          previous += clock.now - oldNow;\n        }\n      };\n\n      postTimerCall = function postTimerCall() {\n        timer = firstTimerInRange(clock, previous, tickTo);\n        previous = tickFrom;\n      };\n\n      return doTickInner();\n    }\n    /**\n     * @param {tickValue} {string|number} number of milliseconds or a human-readable value like \"01:11:15\"\n     */\n\n\n    clock.tick = function tick(tickValue) {\n      return doTick(tickValue, false);\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.tickAsync = function tickAsync(ms) {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              doTick(ms, true, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.next = function next() {\n      runJobs(clock);\n      var timer = firstTimer(clock);\n\n      if (!timer) {\n        return clock.now;\n      }\n\n      clock.duringTick = true;\n\n      try {\n        clock.now = timer.callAt;\n        callTimer(clock, timer);\n        runJobs(clock);\n        return clock.now;\n      } finally {\n        clock.duringTick = false;\n      }\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.nextAsync = function nextAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              var timer = firstTimer(clock);\n\n              if (!timer) {\n                resolve(clock.now);\n                return;\n              }\n\n              var err;\n              clock.duringTick = true;\n              clock.now = timer.callAt;\n\n              try {\n                callTimer(clock, timer);\n              } catch (e) {\n                err = e;\n              }\n\n              clock.duringTick = false;\n              originalSetTimeout(function () {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(clock.now);\n                }\n              });\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.runAll = function runAll() {\n      var numTimers, i;\n      runJobs(clock);\n\n      for (i = 0; i < clock.loopLimit; i++) {\n        if (!clock.timers) {\n          return clock.now;\n        }\n\n        numTimers = Object.keys(clock.timers).length;\n\n        if (numTimers === 0) {\n          return clock.now;\n        }\n\n        clock.next();\n      }\n\n      throw new Error(\"Aborting after running \" + clock.loopLimit + \" timers, assuming an infinite loop!\");\n    };\n\n    clock.runToFrame = function runToFrame() {\n      return clock.tick(getTimeToNextFrame());\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runAllAsync = function runAllAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          var i = 0;\n\n          function doRun() {\n            originalSetTimeout(function () {\n              try {\n                var numTimers;\n\n                if (i < clock.loopLimit) {\n                  if (!clock.timers) {\n                    resolve(clock.now);\n                    return;\n                  }\n\n                  numTimers = Object.keys(clock.timers).length;\n\n                  if (numTimers === 0) {\n                    resolve(clock.now);\n                    return;\n                  }\n\n                  clock.next();\n                  i++;\n                  doRun();\n                  return;\n                }\n\n                reject(new Error(\"Aborting after running \" + clock.loopLimit + \" timers, assuming an infinite loop!\"));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          }\n\n          doRun();\n        });\n      };\n    }\n\n    clock.runToLast = function runToLast() {\n      var timer = lastTimer(clock);\n\n      if (!timer) {\n        runJobs(clock);\n        return clock.now;\n      }\n\n      return clock.tick(timer.callAt - clock.now);\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runToLastAsync = function runToLastAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              var timer = lastTimer(clock);\n\n              if (!timer) {\n                resolve(clock.now);\n              }\n\n              resolve(clock.tickAsync(timer.callAt));\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.reset = function reset() {\n      nanos = 0;\n      clock.timers = {};\n      clock.jobs = [];\n      clock.now = start;\n    };\n\n    clock.setSystemTime = function setSystemTime(systemTime) {\n      // determine time difference\n      var newNow = getEpoch(systemTime);\n      var difference = newNow - clock.now;\n      var id, timer;\n      adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n      adjustedSystemTime[1] = adjustedSystemTime[1] + nanos; // update 'system clock'\n\n      clock.now = newNow;\n      nanos = 0; // update timers and intervals to keep them stable\n\n      for (id in clock.timers) {\n        if (clock.timers.hasOwnProperty(id)) {\n          timer = clock.timers[id];\n          timer.createdAt += difference;\n          timer.callAt += difference;\n        }\n      }\n    };\n\n    if (performancePresent) {\n      clock.performance = Object.create(null);\n\n      if (hasPerformancePrototype) {\n        var proto = _global.Performance.prototype;\n        Object.getOwnPropertyNames(proto).forEach(function (name) {\n          if (name.indexOf(\"getEntries\") === 0) {\n            // match expected return type for getEntries functions\n            clock.performance[name] = NOOP_ARRAY;\n          } else {\n            clock.performance[name] = NOOP;\n          }\n        });\n      }\n\n      clock.performance.now = function FakeTimersNow() {\n        var hrt = hrtime();\n        var millis = hrt[0] * 1000 + hrt[1] / 1e6;\n        return millis;\n      };\n    }\n\n    if (hrtimePresent) {\n      clock.hrtime = hrtime;\n    }\n\n    return clock;\n  }\n  /* eslint-disable complexity */\n\n  /**\n   * @param {Config=} [config] Optional config\n   * @returns {Clock}\n   */\n\n\n  function install(config) {\n    if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || typeof config === \"number\") {\n      throw new TypeError(\"FakeTimers.install called with \" + String(config) + \" install requires an object parameter\");\n    } // eslint-disable-next-line no-param-reassign\n\n\n    config = typeof config !== \"undefined\" ? config : {};\n    config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n    config.advanceTimeDelta = config.advanceTimeDelta || 20;\n\n    if (config.target) {\n      throw new TypeError(\"config.target is no longer supported. Use `withGlobal(target)` instead.\");\n    }\n\n    var i, l;\n    var clock = createClock(config.now, config.loopLimit);\n\n    clock.uninstall = function () {\n      return uninstall(clock, config);\n    };\n\n    clock.methods = config.toFake || [];\n\n    if (clock.methods.length === 0) {\n      // do not fake nextTick by default - GitHub#126\n      clock.methods = Object.keys(timers).filter(function (key) {\n        return key !== \"nextTick\" && key !== \"queueMicrotask\";\n      });\n    }\n\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      if (clock.methods[i] === \"hrtime\") {\n        if (_global.process && typeof _global.process.hrtime === \"function\") {\n          hijackMethod(_global.process, clock.methods[i], clock);\n        }\n      } else if (clock.methods[i] === \"nextTick\") {\n        if (_global.process && typeof _global.process.nextTick === \"function\") {\n          hijackMethod(_global.process, clock.methods[i], clock);\n        }\n      } else {\n        if (clock.methods[i] === \"setInterval\" && config.shouldAdvanceTime === true) {\n          var intervalTick = doIntervalTick.bind(null, clock, config.advanceTimeDelta);\n\n          var intervalId = _global[clock.methods[i]](intervalTick, config.advanceTimeDelta);\n\n          clock.attachedInterval = intervalId;\n        }\n\n        hijackMethod(_global, clock.methods[i], clock);\n      }\n    }\n\n    return clock;\n  }\n  /* eslint-enable complexity */\n\n\n  return {\n    timers: timers,\n    createClock: createClock,\n    install: install,\n    withGlobal: withGlobal\n  };\n}\n/* eslint-enable complexity */\n\n\nvar defaultImplementation = withGlobal(globalObject);\nexports.timers = defaultImplementation.timers;\nexports.createClock = defaultImplementation.createClock;\nexports.install = defaultImplementation.install;\nexports.withGlobal = withGlobal;","map":null,"metadata":{},"sourceType":"module"}