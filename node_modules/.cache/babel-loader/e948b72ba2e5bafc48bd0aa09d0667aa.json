{"ast":null,"code":"import React from 'react';\n\nvar split = function split(expression, operator) {\n  var result = [];\n  var braces = 0;\n  var currentChunk = \"\";\n\n  for (var i = 0; i < expression.length; ++i) {\n    var curCh = expression[i];\n\n    if (curCh == '(') {\n      braces++;\n    } else if (curCh == ')') {\n      braces--;\n    }\n\n    if (braces == 0 && operator == curCh) {\n      result.push(currentChunk);\n      currentChunk = \"\";\n    } else currentChunk += curCh;\n  }\n\n  if (currentChunk != \"\") {\n    result.push(currentChunk);\n  }\n\n  return result;\n}; // this will only take strings containing * operator [ no + ]\n\n\nvar parseMultiplicationSeparatedExpression = function parseMultiplicationSeparatedExpression(expression) {\n  var numbersString = split(expression, '*');\n  var numbers = numbersString.map(function (noStr) {\n    if (noStr[0] == '(') {\n      var expr = noStr.substr(1, noStr.length - 2); // recursive call to the main function\n\n      return parsePlusSeparatedExpression(expr);\n    }\n\n    return +noStr;\n  });\n  var initialValue = 1.0;\n  var result = numbers.reduce(function (acc, no) {\n    return acc * no;\n  }, initialValue);\n  return result;\n}; // both * -\n\n\nvar parseMinusSeparatedExpression = function parseMinusSeparatedExpression(expression) {\n  var numbersString = split(expression, '-');\n  var numbers = numbersString.map(function (noStr) {\n    return parseMultiplicationSeparatedExpression(noStr);\n  });\n  var initialValue = numbers[0];\n  var result = numbers.slice(1).reduce(function (acc, no) {\n    return acc - no;\n  }, initialValue);\n  return result;\n}; // * - + \n\n\nvar parsePlusSeparatedExpression = function parsePlusSeparatedExpression(expression) {\n  var numbersString = split(expression, '+');\n  var numbers = numbersString.map(function (noStr) {\n    return parseMinusSeparatedExpression(noStr);\n  });\n  var initialValue = 0.0;\n  var result = numbers.reduce(function (acc, no) {\n    return acc + no;\n  }, initialValue);\n  return result;\n};\n\nvar Parse = function Parse() {\n  var expressionNode = document.getElementById('expression');\n  var resultNode = document.getElementById('result');\n  var expression = expressionNode.value;\n  var result = parsePlusSeparatedExpression(expression, '+');\n  resultNode.value = String(result);\n};\n\nexport default Parse;","map":{"version":3,"sources":["/Users/volpito/Desktop/projets/PALO_IT_test/palo_it_mrigot/app/javascript/components/TinyArythmeticExpressionParser/TinyArythmeticExpressionParser.js"],"names":["React","split","expression","operator","result","braces","currentChunk","i","length","curCh","push","parseMultiplicationSeparatedExpression","numbersString","numbers","map","noStr","expr","substr","parsePlusSeparatedExpression","initialValue","reduce","acc","no","parseMinusSeparatedExpression","slice","Parse","expressionNode","document","getElementById","resultNode","value","String"],"mappings":"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","sourcesContent":["import React from 'react'\n\nconst split = (expression, operator) => {\n  const result = [];\n  let braces = 0;\n  let currentChunk = \"\";\n  for (let i = 0; i < expression.length; ++i) {\n    const curCh = expression[i];\n    if (curCh == '(') {\n      braces++;\n    } else if (curCh == ')') {\n      braces--;\n    }\n    if (braces == 0 && operator == curCh) {\n      result.push(currentChunk);\n      currentChunk = \"\";\n    } else currentChunk += curCh;\n  }\n  if (currentChunk != \"\") {\n    result.push(currentChunk);\n  }\n  return result;\n};\n\n// this will only take strings containing * operator [ no + ]\nconst parseMultiplicationSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '*');\n  const numbers = numbersString.map(noStr => {\n    if (noStr[0] == '(') {\n      const expr = noStr.substr(1, noStr.length - 2);\n      // recursive call to the main function\n      return parsePlusSeparatedExpression(expr);\n    }\n    return +noStr;\n  });\n  const initialValue = 1.0;\n  const result = numbers.reduce((acc, no) => acc * no, initialValue);\n  return result;\n};\n\n// both * -\nconst parseMinusSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '-');\n  const numbers = numbersString.map(noStr => parseMultiplicationSeparatedExpression(noStr));\n  const initialValue = numbers[0];\n  const result = numbers.slice(1).reduce((acc, no) => acc - no, initialValue);\n  return result;\n};\n\n// * - + \nconst parsePlusSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '+');\n  const numbers = numbersString.map(noStr => parseMinusSeparatedExpression(noStr));\n  const initialValue = 0.0;\n  const result = numbers.reduce((acc, no) => acc + no, initialValue);\n  return result;\n};\n\nconst Parse = () => {\n  const expressionNode = document.getElementById('expression');\n  const resultNode = document.getElementById('result');\n  const expression = expressionNode.value;\n  const result = parsePlusSeparatedExpression(expression, '+');\n  resultNode.value = String(result);\n};\n\nexport default Parse;"]},"metadata":{},"sourceType":"module"}