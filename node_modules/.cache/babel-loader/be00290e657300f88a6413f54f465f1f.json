{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar match = require(\"@sinonjs/samsam\").createMatcher;\n\nvar deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n\nvar functionName = require(\"@sinonjs/commons\").functionName;\n\nvar sinonFormat = require(\"./util/core/format\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar concat = arrayProto.concat;\nvar filter = arrayProto.filter;\nvar join = arrayProto.join;\nvar map = arrayProto.map;\nvar reduce = arrayProto.reduce;\nvar slice = arrayProto.slice;\n\nfunction throwYieldError(proxy, text, args) {\n  var msg = functionName(proxy) + text;\n\n  if (args.length) {\n    msg += \" Received [\".concat(join(slice(args), \", \"), \"]\");\n  }\n\n  throw new Error(msg);\n}\n\nvar callProto = {\n  calledOn: function calledOn(thisValue) {\n    if (match.isMatcher(thisValue)) {\n      return thisValue.test(this.thisValue);\n    }\n\n    return this.thisValue === thisValue;\n  },\n  calledWith: function calledWith() {\n    var self = this;\n    var calledWithArgs = slice(arguments);\n\n    if (calledWithArgs.length > self.args.length) {\n      return false;\n    }\n\n    return reduce(calledWithArgs, function (prev, arg, i) {\n      return prev && deepEqual(self.args[i], arg);\n    }, true);\n  },\n  calledWithMatch: function calledWithMatch() {\n    var self = this;\n    var calledWithMatchArgs = slice(arguments);\n\n    if (calledWithMatchArgs.length > self.args.length) {\n      return false;\n    }\n\n    return reduce(calledWithMatchArgs, function (prev, expectation, i) {\n      var actual = self.args[i];\n      return prev && match(expectation).test(actual);\n    }, true);\n  },\n  calledWithExactly: function calledWithExactly() {\n    return arguments.length === this.args.length && this.calledWith.apply(this, arguments);\n  },\n  notCalledWith: function notCalledWith() {\n    return !this.calledWith.apply(this, arguments);\n  },\n  notCalledWithMatch: function notCalledWithMatch() {\n    return !this.calledWithMatch.apply(this, arguments);\n  },\n  returned: function returned(value) {\n    return deepEqual(this.returnValue, value);\n  },\n  threw: function threw(error) {\n    if (typeof error === \"undefined\" || !this.exception) {\n      return Boolean(this.exception);\n    }\n\n    return this.exception === error || this.exception.name === error;\n  },\n  calledWithNew: function calledWithNew() {\n    return this.proxy.prototype && this.thisValue instanceof this.proxy;\n  },\n  calledBefore: function calledBefore(other) {\n    return this.callId < other.callId;\n  },\n  calledAfter: function calledAfter(other) {\n    return this.callId > other.callId;\n  },\n  calledImmediatelyBefore: function calledImmediatelyBefore(other) {\n    return this.callId === other.callId - 1;\n  },\n  calledImmediatelyAfter: function calledImmediatelyAfter(other) {\n    return this.callId === other.callId + 1;\n  },\n  callArg: function callArg(pos) {\n    this.ensureArgIsAFunction(pos);\n    return this.args[pos]();\n  },\n  callArgOn: function callArgOn(pos, thisValue) {\n    this.ensureArgIsAFunction(pos);\n    return this.args[pos].apply(thisValue);\n  },\n  callArgWith: function callArgWith(pos) {\n    return this.callArgOnWith.apply(this, concat([pos, null], slice(arguments, 1)));\n  },\n  callArgOnWith: function callArgOnWith(pos, thisValue) {\n    this.ensureArgIsAFunction(pos);\n    var args = slice(arguments, 2);\n    return this.args[pos].apply(thisValue, args);\n  },\n  throwArg: function throwArg(pos) {\n    if (pos > this.args.length) {\n      throw new TypeError(\"Not enough arguments: \".concat(pos, \" required but only \").concat(this.args.length, \" present\"));\n    }\n\n    throw this.args[pos];\n  },\n  yield: function _yield() {\n    return this.yieldOn.apply(this, concat([null], slice(arguments, 0)));\n  },\n  yieldOn: function yieldOn(thisValue) {\n    var args = slice(this.args);\n    var yieldFn = filter(args, function (arg) {\n      return typeof arg === \"function\";\n    })[0];\n\n    if (!yieldFn) {\n      throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\n    }\n\n    return yieldFn.apply(thisValue, slice(arguments, 1));\n  },\n  yieldTo: function yieldTo(prop) {\n    return this.yieldToOn.apply(this, concat([prop, null], slice(arguments, 1)));\n  },\n  yieldToOn: function yieldToOn(prop, thisValue) {\n    var args = slice(this.args);\n    var yieldArg = filter(args, function (arg) {\n      return arg && typeof arg[prop] === \"function\";\n    })[0];\n    var yieldFn = yieldArg && yieldArg[prop];\n\n    if (!yieldFn) {\n      throwYieldError(this.proxy, \" cannot yield to '\".concat(valueToString(prop), \"' since no callback was passed.\"), args);\n    }\n\n    return yieldFn.apply(thisValue, slice(arguments, 2));\n  },\n  toString: function toString() {\n    var callStr = this.proxy ? \"\".concat(String(this.proxy), \"(\") : \"\";\n    var formattedArgs;\n\n    if (!this.args) {\n      return \":(\";\n    }\n\n    formattedArgs = map(this.args, function (arg) {\n      return sinonFormat(arg);\n    });\n    callStr = \"\".concat(callStr + join(formattedArgs, \", \"), \")\");\n\n    if (typeof this.returnValue !== \"undefined\") {\n      callStr += \" => \".concat(sinonFormat(this.returnValue));\n    }\n\n    if (this.exception) {\n      callStr += \" !\".concat(this.exception.name);\n\n      if (this.exception.message) {\n        callStr += \"(\".concat(this.exception.message, \")\");\n      }\n    }\n\n    if (this.stack) {\n      // Omit the error message and the two top stack frames in sinon itself:\n      callStr += (this.stack.split(\"\\n\")[3] || \"unknown\").replace(/^\\s*(?:at\\s+|@)?/, \" at \");\n    }\n\n    return callStr;\n  },\n  ensureArgIsAFunction: function ensureArgIsAFunction(pos) {\n    if (typeof this.args[pos] !== \"function\") {\n      throw new TypeError(\"Expected argument at position \".concat(pos, \" to be a Function, but was \").concat(_typeof(this.args[pos])));\n    }\n  }\n};\nObject.defineProperty(callProto, \"stack\", {\n  enumerable: true,\n  configurable: true,\n  get: function get() {\n    return this.errorWithCallStack && this.errorWithCallStack.stack || \"\";\n  }\n});\ncallProto.invokeCallback = callProto.yield;\n\nfunction createProxyCall(proxy, thisValue, args, returnValue, exception, id, errorWithCallStack) {\n  if (typeof id !== \"number\") {\n    throw new TypeError(\"Call id is not a number\");\n  }\n\n  var firstArg, lastArg;\n\n  if (args.length > 0) {\n    firstArg = args[0];\n    lastArg = args[args.length - 1];\n  }\n\n  var proxyCall = Object.create(callProto);\n  var callback = lastArg && typeof lastArg === \"function\" ? lastArg : undefined;\n  proxyCall.proxy = proxy;\n  proxyCall.thisValue = thisValue;\n  proxyCall.args = args;\n  proxyCall.firstArg = firstArg;\n  proxyCall.lastArg = lastArg;\n  proxyCall.callback = callback;\n  proxyCall.returnValue = returnValue;\n  proxyCall.exception = exception;\n  proxyCall.callId = id;\n  proxyCall.errorWithCallStack = errorWithCallStack;\n  return proxyCall;\n}\n\ncreateProxyCall.toString = callProto.toString; // used by mocks\n\nmodule.exports = createProxyCall;","map":null,"metadata":{},"sourceType":"module"}