{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\n\nvar extend = require(\"./extend\");\n\nvar hasOwnProperty = require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar push = require(\"@sinonjs/commons\").prototypes.array.push;\n\nfunction isFunction(obj) {\n  return typeof obj === \"function\" || Boolean(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n  for (var prop in source) {\n    if (!hasOwnProperty(target, prop)) {\n      target[prop] = source[prop];\n    }\n  }\n}\n\nfunction getAccessor(object, property, method) {\n  var accessors = [\"get\", \"set\"];\n  var descriptor = getPropertyDescriptor(object, property);\n\n  for (var i = 0; i < accessors.length; i++) {\n    if (descriptor[accessors[i]] && descriptor[accessors[i]].name === method.name) {\n      return accessors[i];\n    }\n  }\n\n  return null;\n} // Cheap way to detect if we have ES5 support.\n\n\nvar hasES5Support = (\"keys\" in Object);\n\nmodule.exports = function wrapMethod(object, property, method) {\n  if (!object) {\n    throw new TypeError(\"Should wrap property of object\");\n  }\n\n  if (typeof method !== \"function\" && _typeof(method) !== \"object\") {\n    throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n  }\n\n  function checkWrappedMethod(wrappedMethod) {\n    var error;\n\n    if (!isFunction(wrappedMethod)) {\n      error = new TypeError(\"Attempted to wrap \".concat(_typeof(wrappedMethod), \" property \").concat(valueToString(property), \" as function\"));\n    } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \".concat(valueToString(property), \" which is already wrapped\"));\n    } else if (wrappedMethod.calledBefore) {\n      var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n      error = new TypeError(\"Attempted to wrap \".concat(valueToString(property), \" which is already \").concat(verb));\n    }\n\n    if (error) {\n      if (wrappedMethod && wrappedMethod.stackTraceError) {\n        error.stack += \"\\n--------------\\n\".concat(wrappedMethod.stackTraceError.stack);\n      }\n\n      throw error;\n    }\n  }\n\n  var error, wrappedMethods, wrappedMethod, i, wrappedMethodDesc, target, accessor;\n  wrappedMethods = [];\n\n  function simplePropertyAssignment() {\n    wrappedMethod = object[property];\n    checkWrappedMethod(wrappedMethod);\n    object[property] = method;\n    method.displayName = property;\n  } // Firefox has a problem when using hasOwn.call on objects from other frames.\n\n\n  var owned = object.hasOwnProperty ? object.hasOwnProperty(property) // eslint-disable-line @sinonjs/no-prototype-methods/no-prototype-methods\n  : hasOwnProperty(object, property);\n\n  if (hasES5Support) {\n    var methodDesc = typeof method === \"function\" ? {\n      value: method\n    } : method;\n    wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n    if (!wrappedMethodDesc) {\n      error = new TypeError(\"Attempted to wrap \".concat(_typeof(wrappedMethod), \" property \").concat(property, \" as function\"));\n    } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \".concat(property, \" which is already wrapped\"));\n    }\n\n    if (error) {\n      if (wrappedMethodDesc && wrappedMethodDesc.stackTraceError) {\n        error.stack += \"\\n--------------\\n\".concat(wrappedMethodDesc.stackTraceError.stack);\n      }\n\n      throw error;\n    }\n\n    var types = Object.keys(methodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      wrappedMethod = wrappedMethodDesc[types[i]];\n      checkWrappedMethod(wrappedMethod);\n      push(wrappedMethods, wrappedMethod);\n    }\n\n    mirrorProperties(methodDesc, wrappedMethodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n    }\n\n    Object.defineProperty(object, property, methodDesc); // catch failing assignment\n    // this is the converse of the check in `.restore` below\n\n    if (typeof method === \"function\" && object[property] !== method) {\n      // correct any wrongdoings caused by the defineProperty call above,\n      // such as adding new items (if object was a Storage object)\n      delete object[property];\n      simplePropertyAssignment();\n    }\n  } else {\n    simplePropertyAssignment();\n  }\n\n  extendObjectWithWrappedMethods();\n\n  function extendObjectWithWrappedMethods() {\n    for (i = 0; i < wrappedMethods.length; i++) {\n      accessor = getAccessor(object, property, wrappedMethods[i]);\n      target = accessor ? method[accessor] : method;\n      extend.nonEnum(target, {\n        displayName: property,\n        wrappedMethod: wrappedMethods[i],\n        // Set up an Error object for a stack trace which can be used later to find what line of\n        // code the original method was created on.\n        stackTraceError: new Error(\"Stack Trace for original\"),\n        restore: restore\n      });\n      target.restore.sinon = true;\n\n      if (!hasES5Support) {\n        mirrorProperties(target, wrappedMethod);\n      }\n    }\n  }\n\n  function restore() {\n    accessor = getAccessor(object, property, this.wrappedMethod);\n    var descriptor; // For prototype properties try to reset by delete first.\n    // If this fails (ex: localStorage on mobile safari) then force a reset\n    // via direct assignment.\n\n    if (accessor) {\n      if (!owned) {\n        try {\n          // In some cases `delete` may throw an error\n          delete object[property][accessor];\n        } catch (e) {} // eslint-disable-line no-empty\n        // For native code functions `delete` fails without throwing an error\n        // on Chrome < 43, PhantomJS, etc.\n\n      } else if (hasES5Support) {\n        descriptor = getPropertyDescriptor(object, property);\n        descriptor[accessor] = wrappedMethodDesc[accessor];\n        Object.defineProperty(object, property, descriptor);\n      }\n\n      if (hasES5Support) {\n        descriptor = getPropertyDescriptor(object, property);\n\n        if (descriptor && descriptor.value === target) {\n          object[property][accessor] = this.wrappedMethod;\n        }\n      } else {\n        // Use strict equality comparison to check failures then force a reset\n        // via direct assignment.\n        if (object[property][accessor] === target) {\n          object[property][accessor] = this.wrappedMethod;\n        }\n      }\n    } else {\n      if (!owned) {\n        try {\n          delete object[property];\n        } catch (e) {} // eslint-disable-line no-empty\n\n      } else if (hasES5Support) {\n        Object.defineProperty(object, property, wrappedMethodDesc);\n      }\n\n      if (hasES5Support) {\n        descriptor = getPropertyDescriptor(object, property);\n\n        if (descriptor && descriptor.value === target) {\n          object[property] = this.wrappedMethod;\n        }\n      } else {\n        if (object[property] === target) {\n          object[property] = this.wrappedMethod;\n        }\n      }\n    }\n  }\n\n  return method;\n};","map":null,"metadata":{},"sourceType":"module"}