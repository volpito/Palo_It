{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar extend = require(\"./util/core/extend\");\n\nvar functionToString = require(\"./util/core/function-to-string\");\n\nvar proxyCall = require(\"./proxy-call\");\n\nvar proxyCallUtil = require(\"./proxy-call-util\");\n\nvar proxyInvoke = require(\"./proxy-invoke\");\n\nvar sinonFormat = require(\"./util/core/format\");\n\nvar push = arrayProto.push;\nvar forEach = arrayProto.forEach;\nvar slice = arrayProto.slice;\nvar emptyFakes = Object.freeze([]); // Public API\n\nvar proxyApi = {\n  toString: functionToString,\n  named: function named(name) {\n    this.displayName = name;\n    var nameDescriptor = Object.getOwnPropertyDescriptor(this, \"name\");\n\n    if (nameDescriptor && nameDescriptor.configurable) {\n      // IE 11 functions don't have a name.\n      // Safari 9 has names that are not configurable.\n      nameDescriptor.value = name;\n      Object.defineProperty(this, \"name\", nameDescriptor);\n    }\n\n    return this;\n  },\n  invoke: proxyInvoke,\n\n  /*\n   * Hook for derived implementation to return fake instances matching the\n   * given arguments.\n   */\n  matchingFakes: function matchingFakes() {\n    return emptyFakes;\n  },\n  getCall: function getCall(index) {\n    var i = index;\n\n    if (i < 0) {\n      // Negative indices means counting backwards from the last call\n      i += this.callCount;\n    }\n\n    if (i < 0 || i >= this.callCount) {\n      return null;\n    }\n\n    return proxyCall(this, this.thisValues[i], this.args[i], this.returnValues[i], this.exceptions[i], this.callIds[i], this.errorsWithCallStack[i]);\n  },\n  getCalls: function getCalls() {\n    var calls = [];\n    var i;\n\n    for (i = 0; i < this.callCount; i++) {\n      push(calls, this.getCall(i));\n    }\n\n    return calls;\n  },\n  calledBefore: function calledBefore(proxy) {\n    if (!this.called) {\n      return false;\n    }\n\n    if (!proxy.called) {\n      return true;\n    }\n\n    return this.callIds[0] < proxy.callIds[proxy.callIds.length - 1];\n  },\n  calledAfter: function calledAfter(proxy) {\n    if (!this.called || !proxy.called) {\n      return false;\n    }\n\n    return this.callIds[this.callCount - 1] > proxy.callIds[0];\n  },\n  calledImmediatelyBefore: function calledImmediatelyBefore(proxy) {\n    if (!this.called || !proxy.called) {\n      return false;\n    }\n\n    return this.callIds[this.callCount - 1] === proxy.callIds[proxy.callCount - 1] - 1;\n  },\n  calledImmediatelyAfter: function calledImmediatelyAfter(proxy) {\n    if (!this.called || !proxy.called) {\n      return false;\n    }\n\n    return this.callIds[this.callCount - 1] === proxy.callIds[proxy.callCount - 1] + 1;\n  },\n  formatters: require(\"./spy-formatters\"),\n  printf: function printf(format) {\n    var spyInstance = this;\n    var args = slice(arguments, 1);\n    var formatter;\n    return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\n      formatter = proxyApi.formatters[specifyer];\n\n      if (typeof formatter === \"function\") {\n        return String(formatter(spyInstance, args));\n      } else if (!isNaN(parseInt(specifyer, 10))) {\n        return sinonFormat(args[specifyer - 1]);\n      }\n\n      return \"%\".concat(specifyer);\n    });\n  },\n  resetHistory: function resetHistory() {\n    if (this.invoking) {\n      var err = new Error(\"Cannot reset Sinon function while invoking it. \" + \"Move the call to .resetHistory outside of the callback.\");\n      err.name = \"InvalidResetException\";\n      throw err;\n    }\n\n    this.called = false;\n    this.notCalled = true;\n    this.calledOnce = false;\n    this.calledTwice = false;\n    this.calledThrice = false;\n    this.callCount = 0;\n    this.firstCall = null;\n    this.secondCall = null;\n    this.thirdCall = null;\n    this.lastCall = null;\n    this.args = [];\n    this.firstArg = null;\n    this.lastArg = null;\n    this.returnValues = [];\n    this.thisValues = [];\n    this.exceptions = [];\n    this.callIds = [];\n    this.errorsWithCallStack = [];\n\n    if (this.fakes) {\n      forEach(this.fakes, function (fake) {\n        fake.resetHistory();\n      });\n    }\n\n    return this;\n  }\n};\nvar delegateToCalls = proxyCallUtil.delegateToCalls;\ndelegateToCalls(proxyApi, \"calledOn\", true);\ndelegateToCalls(proxyApi, \"alwaysCalledOn\", false, \"calledOn\");\ndelegateToCalls(proxyApi, \"calledWith\", true);\ndelegateToCalls(proxyApi, \"calledOnceWith\", true, \"calledWith\", false, undefined, 1);\ndelegateToCalls(proxyApi, \"calledWithMatch\", true);\ndelegateToCalls(proxyApi, \"alwaysCalledWith\", false, \"calledWith\");\ndelegateToCalls(proxyApi, \"alwaysCalledWithMatch\", false, \"calledWithMatch\");\ndelegateToCalls(proxyApi, \"calledWithExactly\", true);\ndelegateToCalls(proxyApi, \"calledOnceWithExactly\", true, \"calledWithExactly\", false, undefined, 1);\ndelegateToCalls(proxyApi, \"calledOnceWithMatch\", true, \"calledWithMatch\", false, undefined, 1);\ndelegateToCalls(proxyApi, \"alwaysCalledWithExactly\", false, \"calledWithExactly\");\ndelegateToCalls(proxyApi, \"neverCalledWith\", false, \"notCalledWith\", false, function () {\n  return true;\n});\ndelegateToCalls(proxyApi, \"neverCalledWithMatch\", false, \"notCalledWithMatch\", false, function () {\n  return true;\n});\ndelegateToCalls(proxyApi, \"threw\", true);\ndelegateToCalls(proxyApi, \"alwaysThrew\", false, \"threw\");\ndelegateToCalls(proxyApi, \"returned\", true);\ndelegateToCalls(proxyApi, \"alwaysReturned\", false, \"returned\");\ndelegateToCalls(proxyApi, \"calledWithNew\", true);\ndelegateToCalls(proxyApi, \"alwaysCalledWithNew\", false, \"calledWithNew\");\n\nfunction createProxy(func, originalFunc) {\n  var proxy = wrapFunction(func, originalFunc); // Inherit function properties:\n\n  extend(proxy, func);\n  proxy.prototype = func.prototype;\n  extend.nonEnum(proxy, proxyApi);\n  return proxy;\n}\n\nfunction wrapFunction(func, originalFunc) {\n  var arity = originalFunc.length;\n  var p; // Do not change this to use an eval. Projects that depend on sinon block the use of eval.\n  // ref: https://github.com/sinonjs/sinon/issues/710\n\n  switch (arity) {\n    /*eslint-disable no-unused-vars, max-len*/\n    case 0:\n      p = function proxy() {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 1:\n      p = function proxy(a) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 2:\n      p = function proxy(a, b) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 3:\n      p = function proxy(a, b, c) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 4:\n      p = function proxy(a, b, c, d) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 5:\n      p = function proxy(a, b, c, d, e) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 6:\n      p = function proxy(a, b, c, d, e, f) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 7:\n      p = function proxy(a, b, c, d, e, f, g) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 8:\n      p = function proxy(a, b, c, d, e, f, g, h) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 9:\n      p = function proxy(a, b, c, d, e, f, g, h, i) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 10:\n      p = function proxy(a, b, c, d, e, f, g, h, i, j) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 11:\n      p = function proxy(a, b, c, d, e, f, g, h, i, j, k) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    case 12:\n      p = function proxy(a, b, c, d, e, f, g, h, i, j, k, l) {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    default:\n      p = function proxy() {\n        return p.invoke(func, this, slice(arguments));\n      };\n\n      break;\n\n    /*eslint-enable*/\n  }\n\n  var nameDescriptor = Object.getOwnPropertyDescriptor(originalFunc, \"name\");\n\n  if (nameDescriptor && nameDescriptor.configurable) {\n    // IE 11 functions don't have a name.\n    // Safari 9 has names that are not configurable.\n    Object.defineProperty(p, \"name\", nameDescriptor);\n  }\n\n  extend.nonEnum(p, {\n    isSinonProxy: true,\n    called: false,\n    notCalled: true,\n    calledOnce: false,\n    calledTwice: false,\n    calledThrice: false,\n    callCount: 0,\n    firstCall: null,\n    firstArg: null,\n    secondCall: null,\n    thirdCall: null,\n    lastCall: null,\n    lastArg: null,\n    args: [],\n    returnValues: [],\n    thisValues: [],\n    exceptions: [],\n    callIds: [],\n    errorsWithCallStack: []\n  });\n  return p;\n}\n\nmodule.exports = createProxy;","map":null,"metadata":{},"sourceType":"module"}