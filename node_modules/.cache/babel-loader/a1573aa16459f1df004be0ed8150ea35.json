{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar className = require(\"@sinonjs/commons\").className;\n\nvar typeOf = require(\"@sinonjs/commons\").typeOf;\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar objectProto = require(\"@sinonjs/commons\").prototypes.object;\n\nvar mapForEach = require(\"@sinonjs/commons\").prototypes.map.forEach;\n\nvar getClass = require(\"./get-class\");\n\nvar identical = require(\"./identical\");\n\nvar isArguments = require(\"./is-arguments\");\n\nvar isDate = require(\"./is-date\");\n\nvar isElement = require(\"./is-element\");\n\nvar isMap = require(\"./is-map\");\n\nvar isNaN = require(\"./is-nan\");\n\nvar isObject = require(\"./is-object\");\n\nvar isSet = require(\"./is-set\");\n\nvar isSubset = require(\"./is-subset\");\n\nvar concat = arrayProto.concat;\nvar every = arrayProto.every;\nvar push = arrayProto.push;\nvar getTime = Date.prototype.getTime;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar indexOf = arrayProto.indexOf;\nvar keys = Object.keys;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n/**\n * Deep equal comparison. Two values are \"deep equal\" when:\n *\n *   - They are equal, according to samsam.identical\n *   - They are both date objects representing the same time\n *   - They are both arrays containing elements that are all deepEqual\n *   - They are objects with the same set of properties, and each property\n *     in ``actual`` is deepEqual to the corresponding property in ``expectation``\n *\n * Supports cyclic objects.\n *\n * @alias module:samsam.deepEqual\n * @param {*} actual The object to examine\n * @param {*} expectation The object actual is expected to be equal to\n * @param {object} match A value to match on\n * @returns {boolean} Returns true when actual and expectation are considered equal\n */\n\nfunction deepEqualCyclic(actual, expectation, match) {\n  // used for cyclic comparison\n  // contain already visited objects\n  var actualObjects = [];\n  var expectationObjects = []; // contain pathes (position in the object structure)\n  // of the already visited objects\n  // indexes same as in objects arrays\n\n  var actualPaths = [];\n  var expectationPaths = []; // contains combinations of already compared objects\n  // in the manner: { \"$1['ref']$2['ref']\": true }\n\n  var compared = {}; // does the recursion for the deep equal check\n  // eslint-disable-next-line complexity\n\n  return function deepEqual(actualObj, expectationObj, actualPath, expectationPath) {\n    // If both are matchers they must be the same instance in order to be\n    // considered equal If we didn't do that we would end up running one\n    // matcher against the other\n    if (match && match.isMatcher(expectationObj)) {\n      if (match.isMatcher(actualObj)) {\n        return actualObj === expectationObj;\n      }\n\n      return expectationObj.test(actualObj);\n    }\n\n    var actualType = _typeof(actualObj);\n\n    var expectationType = _typeof(expectationObj);\n\n    if (actualObj === expectationObj || isNaN(actualObj) || isNaN(expectationObj) || actualObj === null || expectationObj === null || actualObj === undefined || expectationObj === undefined || actualType !== \"object\" || expectationType !== \"object\") {\n      return identical(actualObj, expectationObj);\n    } // Elements are only equal if identical(expected, actual)\n\n\n    if (isElement(actualObj) || isElement(expectationObj)) {\n      return false;\n    }\n\n    var isActualDate = isDate(actualObj);\n    var isExpectationDate = isDate(expectationObj);\n\n    if (isActualDate || isExpectationDate) {\n      if (!isActualDate || !isExpectationDate || getTime.call(actualObj) !== getTime.call(expectationObj)) {\n        return false;\n      }\n    }\n\n    if (actualObj instanceof RegExp && expectationObj instanceof RegExp) {\n      if (valueToString(actualObj) !== valueToString(expectationObj)) {\n        return false;\n      }\n    }\n\n    if (actualObj instanceof Promise && expectationObj instanceof Promise) {\n      return actualObj === expectationObj;\n    }\n\n    if (actualObj instanceof Error && expectationObj instanceof Error) {\n      return actualObj === expectationObj;\n    }\n\n    var actualClass = getClass(actualObj);\n    var expectationClass = getClass(expectationObj);\n    var actualKeys = keys(actualObj);\n    var expectationKeys = keys(expectationObj);\n    var actualName = className(actualObj);\n    var expectationName = className(expectationObj);\n    var expectationSymbols = typeOf(getOwnPropertySymbols) === \"function\" ? getOwnPropertySymbols(expectationObj) :\n    /* istanbul ignore next: cannot collect coverage for engine that doesn't support Symbol */\n    [];\n    var expectationKeysAndSymbols = concat(expectationKeys, expectationSymbols);\n\n    if (isArguments(actualObj) || isArguments(expectationObj)) {\n      if (actualObj.length !== expectationObj.length) {\n        return false;\n      }\n    } else {\n      if (actualType !== expectationType || actualClass !== expectationClass || actualKeys.length !== expectationKeys.length || actualName && expectationName && actualName !== expectationName) {\n        return false;\n      }\n    }\n\n    if (isSet(actualObj) || isSet(expectationObj)) {\n      if (!isSet(actualObj) || !isSet(expectationObj) || actualObj.size !== expectationObj.size) {\n        return false;\n      }\n\n      return isSubset(actualObj, expectationObj, deepEqual);\n    }\n\n    if (isMap(actualObj) || isMap(expectationObj)) {\n      if (!isMap(actualObj) || !isMap(expectationObj) || actualObj.size !== expectationObj.size) {\n        return false;\n      }\n\n      var mapsDeeplyEqual = true;\n      mapForEach(actualObj, function (value, key) {\n        mapsDeeplyEqual = mapsDeeplyEqual && deepEqualCyclic(value, expectationObj.get(key));\n      });\n      return mapsDeeplyEqual;\n    }\n\n    return every(expectationKeysAndSymbols, function (key) {\n      if (!hasOwnProperty(actualObj, key)) {\n        return false;\n      }\n\n      var actualValue = actualObj[key];\n      var expectationValue = expectationObj[key];\n      var actualObject = isObject(actualValue);\n      var expectationObject = isObject(expectationValue); // determines, if the objects were already visited\n      // (it's faster to check for isObject first, than to\n      // get -1 from getIndex for non objects)\n\n      var actualIndex = actualObject ? indexOf(actualObjects, actualValue) : -1;\n      var expectationIndex = expectationObject ? indexOf(expectationObjects, expectationValue) : -1; // determines the new paths of the objects\n      // - for non cyclic objects the current path will be extended\n      //   by current property name\n      // - for cyclic objects the stored path is taken\n\n      var newActualPath = actualIndex !== -1 ? actualPaths[actualIndex] : \"\".concat(actualPath, \"[\").concat(JSON.stringify(key), \"]\");\n      var newExpectationPath = expectationIndex !== -1 ? expectationPaths[expectationIndex] : \"\".concat(expectationPath, \"[\").concat(JSON.stringify(key), \"]\");\n      var combinedPath = newActualPath + newExpectationPath; // stop recursion if current objects are already compared\n\n      if (compared[combinedPath]) {\n        return true;\n      } // remember the current objects and their paths\n\n\n      if (actualIndex === -1 && actualObject) {\n        push(actualObjects, actualValue);\n        push(actualPaths, newActualPath);\n      }\n\n      if (expectationIndex === -1 && expectationObject) {\n        push(expectationObjects, expectationValue);\n        push(expectationPaths, newExpectationPath);\n      } // remember that the current objects are already compared\n\n\n      if (actualObject && expectationObject) {\n        compared[combinedPath] = true;\n      } // End of cyclic logic\n      // neither actualValue nor expectationValue is a cycle\n      // continue with next level\n\n\n      return deepEqual(actualValue, expectationValue, newActualPath, newExpectationPath);\n    });\n  }(actual, expectation, \"$1\", \"$2\");\n}\n\ndeepEqualCyclic.use = function (match) {\n  return function deepEqual(a, b) {\n    return deepEqualCyclic(a, b, match);\n  };\n};\n\nmodule.exports = deepEqualCyclic;","map":null,"metadata":{},"sourceType":"module"}