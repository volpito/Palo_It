{"ast":null,"code":"import _defineProperty from \"/Users/volpito/Desktop/projets/PALO_IT_test/palo_it_mrigot/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _jsxFileName = \"/Users/volpito/Desktop/projets/PALO_IT_test/palo_it_mrigot/app/javascript/components/TinyArythmeticExpressionParser/TinyArythmeticExpressionParser.js\",\n    _this = this;\n\nimport React from 'react';\n\nvar split = function split(expression, operator) {\n  var result = [];\n  var braces = 0;\n  var currentChunk = \"\";\n\n  for (var i = 0; i < expression.length; ++i) {\n    var curCh = expression[i];\n\n    if (curCh == '(') {\n      braces++;\n    } else if (curCh == ')') {\n      braces--;\n    }\n\n    if (braces == 0 && operator == curCh) {\n      result.push(currentChunk);\n      currentChunk = \"\";\n    } else currentChunk += curCh;\n  }\n\n  if (currentChunk != \"\") {\n    result.push(currentChunk);\n  }\n\n  return result;\n}; // this will only take strings containing * operator [ no + ]\n\n\nvar parseMultiplicationSeparatedExpression = function parseMultiplicationSeparatedExpression(expression) {\n  console.log(expression);\n  var numbersStringMultiplication = split(expression, '*');\n  var numbersStringDivision = split(expression, '/');\n  var numbersMultiply = numbersStringMultiplication.map(function (noStr) {\n    if (noStr[0] == '(') {\n      var expr = noStr.substr(1, noStr.length - 2); // recursive call to the main function\n\n      return parsePlusSeparatedExpression(expr);\n    }\n\n    return +noStr;\n  });\n  var numbersDivide = numbersStringDivision.map(function (noStr) {\n    if (noStr[0] == '(') {\n      var expr = noStr.substr(1, noStr.length - 2); // recursive call to the main function\n\n      return parsePlusSeparatedExpression(expr);\n    }\n\n    return +noStr;\n  });\n  var initialValue = 1.0;\n  var result = numbersDivide.reduce(function (acc, no) {\n    return acc / no;\n  }, initialValue);\n  return result;\n};\n/*/ this will only take strings containing / operator [ no + ]\n\nconst parseDivisionSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '/');\n  const numbers = numbersString.map(noStr => {\n    if (noStr[0] == '(') {\n      const expr = noStr.substr(1, noStr.length - 2);\n      // recursive call to the main function\n      return parsePlusSeparatedExpression(expr);\n    }else{\n    parseMultiplicationSeparatedExpression(noStr);\n  }});\n  const initialValue = 1.0;\n  const result = numbers.reduce((acc, no) => acc / no, initialValue);\n  return result;\n};\n\n//this will dispach the expression whether it needs dividing or multiplying\nconst dispach = (expression) =>{\n  if (expression.includes('/')){\n    parseDivisionSeparatedExpression(expression);\n  }else if (expression.includes('*')){\n    parseMultiplicationSeparatedExpression(expression);\n  }\n}*/\n// both * -\n\n\nvar parseMinusSeparatedExpression = function parseMinusSeparatedExpression(expression) {\n  var numbersString = split(expression, '-');\n  var numbers = numbersString.map(function (noStr) {\n    return parseMultiplicationSeparatedExpression(noStr);\n  });\n  var initialValue = numbers[0];\n  var result = numbers.slice(1).reduce(function (acc, no) {\n    return acc - no;\n  }, initialValue);\n  return result;\n}; // * - + \n\n\nvar parsePlusSeparatedExpression = function parsePlusSeparatedExpression(expression) {\n  var numbersString = split(expression, '+');\n  var numbers = numbersString.map(function (noStr) {\n    return parseMinusSeparatedExpression(noStr);\n  });\n  var initialValue = 0.0;\n  var result = numbers.reduce(function (acc, no) {\n    return acc + no;\n  }, initialValue);\n  return result;\n};\n\nvar Parse = function Parse(_ref) {\n  var _React$createElement, _React$createElement2;\n\n  var expression = _ref.expression;\n  var search = ',';\n  var replaceWith = '.';\n  var res = expression.split(search).join(replaceWith);\n  var result = parsePlusSeparatedExpression(res, '+');\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", (_React$createElement2 = {\n    className: \"flex m-4\",\n    __self: _this\n  }, _defineProperty(_React$createElement2, \"__self\", _this), _defineProperty(_React$createElement2, \"__source\", {\n    fileName: _jsxFileName,\n    lineNumber: 106,\n    columnNumber: 5\n  }), _React$createElement2), /*#__PURE__*/React.createElement(\"p\", (_React$createElement = {\n    __self: _this\n  }, _defineProperty(_React$createElement, \"__self\", _this), _defineProperty(_React$createElement, \"__source\", {\n    fileName: _jsxFileName,\n    lineNumber: 107,\n    columnNumber: 7\n  }), _React$createElement), expression, \" is equal to : \", result)));\n};\n\nexport default Parse;","map":{"version":3,"sources":["/Users/volpito/Desktop/projets/PALO_IT_test/palo_it_mrigot/app/javascript/components/TinyArythmeticExpressionParser/TinyArythmeticExpressionParser.js"],"names":["React","split","expression","operator","result","braces","currentChunk","i","length","curCh","push","parseMultiplicationSeparatedExpression","console","log","numbersStringMultiplication","numbersStringDivision","numbersMultiply","map","noStr","expr","substr","parsePlusSeparatedExpression","numbersDivide","initialValue","reduce","acc","no","parseMinusSeparatedExpression","numbersString","numbers","slice","Parse","search","replaceWith","res","join"],"mappings":"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","sourcesContent":["import React from 'react'\n\nconst split = (expression, operator) => {\n  const result = [];\n  let braces = 0;\n  let currentChunk = \"\";\n  for (let i = 0; i < expression.length; ++i) {\n    const curCh = expression[i];\n    if (curCh == '(') {\n      braces++;\n    } else if (curCh == ')') {\n      braces--;\n    }\n    if (braces == 0 && operator == curCh) {\n      result.push(currentChunk);\n      currentChunk = \"\";\n    } else currentChunk += curCh;\n  }\n  if (currentChunk != \"\") {\n    result.push(currentChunk);\n  }\n  return result;\n};\n\n// this will only take strings containing * operator [ no + ]\nconst parseMultiplicationSeparatedExpression = (expression) => {\n  console.log(expression)\n  const numbersStringMultiplication = split(expression, '*');\n  const numbersStringDivision = split(expression, '/');\n\n  const numbersMultiply = numbersStringMultiplication.map(noStr => {\n    if (noStr[0] == '(') {\n      const expr = noStr.substr(1, noStr.length - 2);\n      // recursive call to the main function\n      return parsePlusSeparatedExpression(expr);\n    }\n    return +noStr;\n  });\n  const numbersDivide = numbersStringDivision.map(noStr => {\n    if (noStr[0] == '(') {\n      const expr = noStr.substr(1, noStr.length - 2);\n      // recursive call to the main function\n      return parsePlusSeparatedExpression(expr);\n    }\n    return +noStr;\n  });\n\n  const initialValue = 1.0;\n  const result = numbersDivide.reduce((acc, no) => acc / no, initialValue);\n  return result;\n};\n\n/*/ this will only take strings containing / operator [ no + ]\n\nconst parseDivisionSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '/');\n  const numbers = numbersString.map(noStr => {\n    if (noStr[0] == '(') {\n      const expr = noStr.substr(1, noStr.length - 2);\n      // recursive call to the main function\n      return parsePlusSeparatedExpression(expr);\n    }else{\n    parseMultiplicationSeparatedExpression(noStr);\n  }});\n  const initialValue = 1.0;\n  const result = numbers.reduce((acc, no) => acc / no, initialValue);\n  return result;\n};\n\n//this will dispach the expression whether it needs dividing or multiplying\nconst dispach = (expression) =>{\n  if (expression.includes('/')){\n    parseDivisionSeparatedExpression(expression);\n  }else if (expression.includes('*')){\n    parseMultiplicationSeparatedExpression(expression);\n  }\n}*/\n\n// both * -\nconst parseMinusSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '-');\n  const numbers = numbersString.map(noStr => parseMultiplicationSeparatedExpression(noStr));\n  const initialValue = numbers[0];\n  const result = numbers.slice(1).reduce((acc, no) => acc - no, initialValue);\n  return result;\n};\n\n// * - + \nconst parsePlusSeparatedExpression = (expression) => {\n  const numbersString = split(expression, '+');\n  const numbers = numbersString.map(noStr => parseMinusSeparatedExpression(noStr));\n  const initialValue = 0.0;\n  const result = numbers.reduce((acc, no) => acc + no, initialValue);\n  return result;\n};\n\nconst Parse = ({expression}) => {\n\n  const search = ',';\n  const replaceWith = '.';\n  const res = expression.split(search).join(replaceWith);\n  const result = parsePlusSeparatedExpression(res, '+');\n\n  return (\n    <>\n    <div className=\"flex m-4\">\n      <p >{expression} is equal to : {result}</p>\n    </div>\n    </>\n  )\n};\n\nexport default Parse;"]},"metadata":{},"sourceType":"module"}