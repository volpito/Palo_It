{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar calledInOrder = require(\"@sinonjs/commons\").calledInOrder;\n\nvar createMatcher = require(\"@sinonjs/samsam\").createMatcher;\n\nvar orderByFirstCall = require(\"@sinonjs/commons\").orderByFirstCall;\n\nvar timesInWords = require(\"./util/core/times-in-words\");\n\nvar format = require(\"./util/core/format\");\n\nvar stringSlice = require(\"@sinonjs/commons\").prototypes.string.slice;\n\nvar globalObject = require(\"@sinonjs/commons\").global;\n\nvar arraySlice = arrayProto.slice;\nvar concat = arrayProto.concat;\nvar forEach = arrayProto.forEach;\nvar join = arrayProto.join;\nvar splice = arrayProto.splice;\n\nfunction createAssertObject() {\n  var assert;\n\n  function verifyIsStub() {\n    var args = arraySlice(arguments);\n    forEach(args, function (method) {\n      if (!method) {\n        assert.fail(\"fake is not a spy\");\n      }\n\n      if (method.proxy && method.proxy.isSinonProxy) {\n        verifyIsStub(method.proxy);\n      } else {\n        if (typeof method !== \"function\") {\n          assert.fail(\"\".concat(method, \" is not a function\"));\n        }\n\n        if (typeof method.getCall !== \"function\") {\n          assert.fail(\"\".concat(method, \" is not stubbed\"));\n        }\n      }\n    });\n  }\n\n  function verifyIsValidAssertion(assertionMethod, assertionArgs) {\n    switch (assertionMethod) {\n      case \"notCalled\":\n      case \"called\":\n      case \"calledOnce\":\n      case \"calledTwice\":\n      case \"calledThrice\":\n        if (assertionArgs.length !== 0) {\n          assert.fail(\"\".concat(assertionMethod, \" takes 1 argument but was called with \").concat(assertionArgs.length + 1, \" arguments\"));\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  function failAssertion(object, msg) {\n    var obj = object || globalObject;\n    var failMethod = obj.fail || assert.fail;\n    failMethod.call(obj, msg);\n  }\n\n  function mirrorPropAsAssertion(name, method, message) {\n    var msg = message;\n    var meth = method;\n\n    if (arguments.length === 2) {\n      msg = method;\n      meth = name;\n    }\n\n    assert[name] = function (fake) {\n      verifyIsStub(fake);\n      var args = arraySlice(arguments, 1);\n      var failed = false;\n      verifyIsValidAssertion(name, args);\n\n      if (typeof meth === \"function\") {\n        failed = !meth(fake);\n      } else {\n        failed = typeof fake[meth] === \"function\" ? !fake[meth].apply(fake, args) : !fake[meth];\n      }\n\n      if (failed) {\n        failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, concat([msg], args)));\n      } else {\n        assert.pass(name);\n      }\n    };\n  }\n\n  function exposedName(prefix, prop) {\n    return !prefix || /^fail/.test(prop) ? prop : prefix + stringSlice(prop, 0, 1).toUpperCase() + stringSlice(prop, 1);\n  }\n\n  assert = {\n    failException: \"AssertError\",\n    fail: function fail(message) {\n      var error = new Error(message);\n      error.name = this.failException || assert.failException;\n      throw error;\n    },\n    pass: function pass() {\n      return;\n    },\n    callOrder: function assertCallOrder() {\n      verifyIsStub.apply(null, arguments);\n      var expected = \"\";\n      var actual = \"\";\n\n      if (!calledInOrder(arguments)) {\n        try {\n          expected = join(arguments, \", \");\n          var calls = arraySlice(arguments);\n          var i = calls.length;\n\n          while (i) {\n            if (!calls[--i].called) {\n              splice(calls, i, 1);\n            }\n          }\n\n          actual = join(orderByFirstCall(calls), \", \");\n        } catch (e) {// If this fails, we'll just fall back to the blank string\n        }\n\n        failAssertion(this, \"expected \".concat(expected, \" to be called in order but were called as \").concat(actual));\n      } else {\n        assert.pass(\"callOrder\");\n      }\n    },\n    callCount: function assertCallCount(method, count) {\n      verifyIsStub(method);\n\n      if (method.callCount !== count) {\n        var msg = \"expected %n to be called \".concat(timesInWords(count), \" but was called %c%C\");\n        failAssertion(this, method.printf(msg));\n      } else {\n        assert.pass(\"callCount\");\n      }\n    },\n    expose: function expose(target, options) {\n      if (!target) {\n        throw new TypeError(\"target is null or undefined\");\n      }\n\n      var o = options || {};\n      var prefix = typeof o.prefix === \"undefined\" && \"assert\" || o.prefix;\n      var includeFail = typeof o.includeFail === \"undefined\" || Boolean(o.includeFail);\n      var instance = this;\n      forEach(Object.keys(instance), function (method) {\n        if (method !== \"expose\" && (includeFail || !/^(fail)/.test(method))) {\n          target[exposedName(prefix, method)] = instance[method];\n        }\n      });\n      return target;\n    },\n    match: function match(actual, expectation) {\n      var matcher = createMatcher(expectation);\n\n      if (matcher.test(actual)) {\n        assert.pass(\"match\");\n      } else {\n        var formatted = [\"expected value to match\", \"    expected = \".concat(format(expectation)), \"    actual = \".concat(format(actual))];\n        failAssertion(this, join(formatted, \"\\n\"));\n      }\n    }\n  };\n  mirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\n  mirrorPropAsAssertion(\"notCalled\", function (spy) {\n    return !spy.called;\n  }, \"expected %n to not have been called but was called %c%C\");\n  mirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\n  mirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\n  mirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\n  mirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\n  mirrorPropAsAssertion(\"alwaysCalledOn\", \"expected %n to always be called with %1 as this but was called with %t\");\n  mirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\n  mirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\n  mirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %D\");\n  mirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %D\");\n  mirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %D\");\n  mirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %D\");\n  mirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %D\");\n  mirrorPropAsAssertion(\"calledOnceWithExactly\", \"expected %n to be called once and with exact arguments %D\");\n  mirrorPropAsAssertion(\"calledOnceWithMatch\", \"expected %n to be called once and with match %D\");\n  mirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %D\");\n  mirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\n  mirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\n  mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\n  mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n  return assert;\n}\n\nmodule.exports = createAssertObject();\nmodule.exports.createAssertObject = createAssertObject;","map":null,"metadata":{},"sourceType":"module"}