{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar createProxy = require(\"./proxy\");\n\nvar nextTick = require(\"./util/core/next-tick\");\n\nvar slice = arrayProto.slice;\nvar promiseLib = Promise;\nmodule.exports = fake;\n/**\n * Returns a `fake` that records all calls, arguments and return values.\n *\n * When an `f` argument is supplied, this implementation will be used.\n *\n * @example\n * // create an empty fake\n * var f1 = sinon.fake();\n *\n * f1();\n *\n * f1.calledOnce()\n * // true\n *\n * @example\n * function greet(greeting) {\n *   console.log(`Hello ${greeting}`);\n * }\n *\n * // create a fake with implementation\n * var f2 = sinon.fake(greet);\n *\n * // Hello world\n * f2(\"world\");\n *\n * f2.calledWith(\"world\");\n * // true\n *\n * @param {Function|undefined} f\n * @returns {Function}\n * @namespace\n */\n\nfunction fake(f) {\n  if (arguments.length > 0 && typeof f !== \"function\") {\n    throw new TypeError(\"Expected f argument to be a Function\");\n  }\n\n  return wrapFunc(f);\n}\n/**\n * Creates a `fake` that returns the provided `value`, as well as recording all\n * calls, arguments and return values.\n *\n * @example\n * var f1 = sinon.fake.returns(42);\n *\n * f1();\n * // 42\n *\n * @memberof fake\n * @param {*} value\n * @returns {Function}\n */\n\n\nfake.returns = function returns(value) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function f() {\n    return value;\n  }\n\n  return wrapFunc(f);\n};\n/**\n * Creates a `fake` that throws an Error.\n * If the `value` argument does not have Error in its prototype chain, it will\n * be used for creating a new error.\n *\n * @example\n * var f1 = sinon.fake.throws(\"hello\");\n *\n * f1();\n * // Uncaught Error: hello\n *\n * @example\n * var f2 = sinon.fake.throws(new TypeError(\"Invalid argument\"));\n *\n * f2();\n * // Uncaught TypeError: Invalid argument\n *\n * @memberof fake\n * @param {*|Error} value\n * @returns {Function}\n */\n\n\nfake.throws = function throws(value) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function f() {\n    throw getError(value);\n  }\n\n  return wrapFunc(f);\n};\n/**\n * Creates a `fake` that returns a promise that resolves to the passed `value`\n * argument.\n *\n * @example\n * var f1 = sinon.fake.resolves(\"apple pie\");\n *\n * await f1();\n * // \"apple pie\"\n *\n * @memberof fake\n * @param {*} value\n * @returns {Function}\n */\n\n\nfake.resolves = function resolves(value) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function f() {\n    return promiseLib.resolve(value);\n  }\n\n  return wrapFunc(f);\n};\n/**\n * Creates a `fake` that returns a promise that rejects to the passed `value`\n * argument. When `value` does not have Error in its prototype chain, it will be\n * wrapped in an Error.\n *\n * @example\n * var f1 = sinon.fake.rejects(\":(\");\n *\n * try {\n *   await ft();\n * } catch (error) {\n *   console.log(error);\n *   // \":(\"\n * }\n *\n * @memberof fake\n * @param {*} value\n * @returns {Function}\n */\n\n\nfake.rejects = function rejects(value) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function f() {\n    return promiseLib.reject(getError(value));\n  }\n\n  return wrapFunc(f);\n};\n/**\n * Causes `fake` to use a custom Promise implementation, instead of the native\n * Promise implementation.\n *\n * @example\n * const bluebird = require(\"bluebird\");\n * sinon.fake.usingPromise(bluebird);\n *\n * @memberof fake\n * @param {*} promiseLibrary\n * @returns {Function}\n */\n\n\nfake.usingPromise = function usingPromise(promiseLibrary) {\n  promiseLib = promiseLibrary;\n  return fake;\n};\n/**\n * Returns a `fake` that calls the callback with the defined arguments.\n *\n * @example\n * function callback() {\n *   console.log(arguments.join(\"*\"));\n * }\n *\n * const f1 = sinon.fake.yields(\"apple\", \"pie\");\n *\n * f1(callback);\n * // \"apple*pie\"\n *\n * @memberof fake\n * @returns {Function}\n */\n\n\nfake.yields = function yields() {\n  var values = slice(arguments); // eslint-disable-next-line jsdoc/require-jsdoc\n\n  function f() {\n    var callback = arguments[arguments.length - 1];\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"Expected last argument to be a function\");\n    }\n\n    callback.apply(null, values);\n  }\n\n  return wrapFunc(f);\n};\n/**\n * Returns a `fake` that calls the callback **asynchronously** with the\n * defined arguments.\n *\n * @example\n * function callback() {\n *   console.log(arguments.join(\"*\"));\n * }\n *\n * const f1 = sinon.fake.yields(\"apple\", \"pie\");\n *\n * f1(callback);\n *\n * setTimeout(() => {\n *   // \"apple*pie\"\n * });\n *\n * @memberof fake\n * @returns {Function}\n */\n\n\nfake.yieldsAsync = function yieldsAsync() {\n  var values = slice(arguments); // eslint-disable-next-line jsdoc/require-jsdoc\n\n  function f() {\n    var callback = arguments[arguments.length - 1];\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"Expected last argument to be a function\");\n    }\n\n    nextTick(function () {\n      callback.apply(null, values);\n    });\n  }\n\n  return wrapFunc(f);\n};\n\nvar uuid = 0;\n/**\n * Creates a proxy (sinon concept) from the passed function.\n *\n * @private\n * @param  {Function} f\n * @returns {Function}\n */\n\nfunction wrapFunc(f) {\n  var proxy;\n\n  var fakeInstance = function fakeInstance() {\n    var firstArg, lastArg;\n\n    if (arguments.length > 0) {\n      firstArg = arguments[0];\n      lastArg = arguments[arguments.length - 1];\n    }\n\n    var callback = lastArg && typeof lastArg === \"function\" ? lastArg : undefined;\n    proxy.firstArg = firstArg;\n    proxy.lastArg = lastArg;\n    proxy.callback = callback;\n    return f && f.apply(this, arguments);\n  };\n\n  proxy = createProxy(fakeInstance, f || fakeInstance);\n  proxy.displayName = \"fake\";\n  proxy.id = \"fake#\".concat(uuid++);\n  return proxy;\n}\n/**\n * Returns an Error instance from the passed value, if the value is not\n * already an Error instance.\n *\n * @private\n * @param  {*} value [description]\n * @returns {Error}       [description]\n */\n\n\nfunction getError(value) {\n  return value instanceof Error ? value : new Error(value);\n}","map":null,"metadata":{},"sourceType":"module"}