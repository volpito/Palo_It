{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar proxyInvoke = require(\"./proxy-invoke\");\n\nvar proxyCallToString = require(\"./proxy-call\").toString;\n\nvar timesInWords = require(\"./util/core/times-in-words\");\n\nvar extend = require(\"./util/core/extend\");\n\nvar match = require(\"@sinonjs/samsam\").createMatcher;\n\nvar stub = require(\"./stub\");\n\nvar assert = require(\"./assert\");\n\nvar deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n\nvar format = require(\"./util/core/format\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar every = arrayProto.every;\nvar forEach = arrayProto.forEach;\nvar push = arrayProto.push;\nvar slice = arrayProto.slice;\n\nfunction callCountInWords(callCount) {\n  if (callCount === 0) {\n    return \"never called\";\n  }\n\n  return \"called \".concat(timesInWords(callCount));\n}\n\nfunction expectedCallCountInWords(expectation) {\n  var min = expectation.minCalls;\n  var max = expectation.maxCalls;\n\n  if (typeof min === \"number\" && typeof max === \"number\") {\n    var str = timesInWords(min);\n\n    if (min !== max) {\n      str = \"at least \".concat(str, \" and at most \").concat(timesInWords(max));\n    }\n\n    return str;\n  }\n\n  if (typeof min === \"number\") {\n    return \"at least \".concat(timesInWords(min));\n  }\n\n  return \"at most \".concat(timesInWords(max));\n}\n\nfunction receivedMinCalls(expectation) {\n  var hasMinLimit = typeof expectation.minCalls === \"number\";\n  return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n}\n\nfunction receivedMaxCalls(expectation) {\n  if (typeof expectation.maxCalls !== \"number\") {\n    return false;\n  }\n\n  return expectation.callCount === expectation.maxCalls;\n}\n\nfunction verifyMatcher(possibleMatcher, arg) {\n  var isMatcher = match.isMatcher(possibleMatcher);\n  return isMatcher && possibleMatcher.test(arg) || true;\n}\n\nvar mockExpectation = {\n  minCalls: 1,\n  maxCalls: 1,\n  create: function create(methodName) {\n    var expectation = extend.nonEnum(stub(), mockExpectation);\n    delete expectation.create;\n    expectation.method = methodName;\n    return expectation;\n  },\n  invoke: function invoke(func, thisValue, args) {\n    this.verifyCallAllowed(thisValue, args);\n    return proxyInvoke.apply(this, arguments);\n  },\n  atLeast: function atLeast(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\".concat(valueToString(num), \"' is not number\"));\n    }\n\n    if (!this.limitsSet) {\n      this.maxCalls = null;\n      this.limitsSet = true;\n    }\n\n    this.minCalls = num;\n    return this;\n  },\n  atMost: function atMost(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\".concat(valueToString(num), \"' is not number\"));\n    }\n\n    if (!this.limitsSet) {\n      this.minCalls = null;\n      this.limitsSet = true;\n    }\n\n    this.maxCalls = num;\n    return this;\n  },\n  never: function never() {\n    return this.exactly(0);\n  },\n  once: function once() {\n    return this.exactly(1);\n  },\n  twice: function twice() {\n    return this.exactly(2);\n  },\n  thrice: function thrice() {\n    return this.exactly(3);\n  },\n  exactly: function exactly(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\".concat(valueToString(num), \"' is not a number\"));\n    }\n\n    this.atLeast(num);\n    return this.atMost(num);\n  },\n  met: function met() {\n    return !this.failed && receivedMinCalls(this);\n  },\n  verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n    var expectedArguments = this.expectedArguments;\n\n    if (receivedMaxCalls(this)) {\n      this.failed = true;\n      mockExpectation.fail(\"\".concat(this.method, \" already called \").concat(timesInWords(this.maxCalls)));\n    }\n\n    if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n      mockExpectation.fail(\"\".concat(this.method, \" called with \").concat(valueToString(thisValue), \" as thisValue, expected \").concat(valueToString(this.expectedThis)));\n    }\n\n    if (!(\"expectedArguments\" in this)) {\n      return;\n    }\n\n    if (!args) {\n      mockExpectation.fail(\"\".concat(this.method, \" received no arguments, expected \").concat(format(expectedArguments)));\n    }\n\n    if (args.length < expectedArguments.length) {\n      mockExpectation.fail(\"\".concat(this.method, \" received too few arguments (\").concat(format(args), \"), expected \").concat(format(expectedArguments)));\n    }\n\n    if (this.expectsExactArgCount && args.length !== expectedArguments.length) {\n      mockExpectation.fail(\"\".concat(this.method, \" received too many arguments (\").concat(format(args), \"), expected \").concat(format(expectedArguments)));\n    }\n\n    forEach(expectedArguments, function (expectedArgument, i) {\n      if (!verifyMatcher(expectedArgument, args[i])) {\n        mockExpectation.fail(\"\".concat(this.method, \" received wrong arguments \").concat(format(args), \", didn't match \").concat(String(expectedArguments)));\n      }\n\n      if (!deepEqual(args[i], expectedArgument)) {\n        mockExpectation.fail(\"\".concat(this.method, \" received wrong arguments \").concat(format(args), \", expected \").concat(format(expectedArguments)));\n      }\n    }, this);\n  },\n  allowsCall: function allowsCall(thisValue, args) {\n    var expectedArguments = this.expectedArguments;\n\n    if (this.met() && receivedMaxCalls(this)) {\n      return false;\n    }\n\n    if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n      return false;\n    }\n\n    if (!(\"expectedArguments\" in this)) {\n      return true;\n    } // eslint-disable-next-line no-underscore-dangle\n\n\n    var _args = args || [];\n\n    if (_args.length < expectedArguments.length) {\n      return false;\n    }\n\n    if (this.expectsExactArgCount && _args.length !== expectedArguments.length) {\n      return false;\n    }\n\n    return every(expectedArguments, function (expectedArgument, i) {\n      if (!verifyMatcher(expectedArgument, _args[i])) {\n        return false;\n      }\n\n      if (!deepEqual(_args[i], expectedArgument)) {\n        return false;\n      }\n\n      return true;\n    });\n  },\n  withArgs: function withArgs() {\n    this.expectedArguments = slice(arguments);\n    return this;\n  },\n  withExactArgs: function withExactArgs() {\n    this.withArgs.apply(this, arguments);\n    this.expectsExactArgCount = true;\n    return this;\n  },\n  on: function on(thisValue) {\n    this.expectedThis = thisValue;\n    return this;\n  },\n  toString: function toString() {\n    var args = slice(this.expectedArguments || []);\n\n    if (!this.expectsExactArgCount) {\n      push(args, \"[...]\");\n    }\n\n    var callStr = proxyCallToString.call({\n      proxy: this.method || \"anonymous mock expectation\",\n      args: args\n    });\n    var message = \"\".concat(callStr.replace(\", [...\", \"[, ...\"), \" \").concat(expectedCallCountInWords(this));\n\n    if (this.met()) {\n      return \"Expectation met: \".concat(message);\n    }\n\n    return \"Expected \".concat(message, \" (\").concat(callCountInWords(this.callCount), \")\");\n  },\n  verify: function verify() {\n    if (!this.met()) {\n      mockExpectation.fail(String(this));\n    } else {\n      mockExpectation.pass(String(this));\n    }\n\n    return true;\n  },\n  pass: function pass(message) {\n    assert.pass(message);\n  },\n  fail: function fail(message) {\n    var exception = new Error(message);\n    exception.name = \"ExpectationError\";\n    throw exception;\n  }\n};\nmodule.exports = mockExpectation;","map":null,"metadata":{},"sourceType":"module"}