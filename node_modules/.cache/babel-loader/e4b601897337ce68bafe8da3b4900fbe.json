{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\nimport { format as formatUrl } from 'url';\nimport Headers from './headers.js';\nimport Body, { clone, extractContentType, getTotalBytes } from './body.js';\nimport { isAbortSignal } from './utils/is.js';\nimport { getSearch } from './utils/get-search.js';\nvar INTERNALS = Symbol('Request internals');\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} obj\n * @return {boolean}\n */\n\nvar isRequest = function isRequest(object) {\n  return _typeof(object) === 'object' && _typeof(object[INTERNALS]) === 'object';\n};\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\n\n\nvar Request = /*#__PURE__*/function (_Body, _Symbol$toStringTag) {\n  _inherits(Request, _Body);\n\n  var _super = _createSuper(Request);\n\n  function Request(input) {\n    var _this;\n\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Request);\n\n    var parsedURL; // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\n    if (isRequest(input)) {\n      parsedURL = new URL(input.url);\n    } else {\n      parsedURL = new URL(input);\n      input = {};\n    }\n\n    var method = init.method || input.method || 'GET';\n    method = method.toUpperCase(); // eslint-disable-next-line no-eq-null, eqeqeq\n\n    if ((init.body != null || isRequest(input)) && input.body !== null && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n\n    var inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    _this = _super.call(this, inputBody, {\n      size: init.size || input.size || 0\n    });\n    var headers = new Headers(init.headers || input.headers || {});\n\n    if (inputBody !== null && !headers.has('Content-Type')) {\n      var contentType = extractContentType(inputBody, _assertThisInitialized(_this));\n\n      if (contentType) {\n        headers.append('Content-Type', contentType);\n      }\n    }\n\n    var signal = isRequest(input) ? input.signal : null;\n\n    if ('signal' in init) {\n      signal = init.signal;\n    } // eslint-disable-next-line no-eq-null, eqeqeq\n\n\n    if (signal != null && !isAbortSignal(signal)) {\n      throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n    }\n\n    _this[INTERNALS] = {\n      method: method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers: headers,\n      parsedURL: parsedURL,\n      signal: signal\n    }; // Node-fetch-only options\n\n    _this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;\n    _this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;\n    _this.counter = init.counter || input.counter || 0;\n    _this.agent = init.agent || input.agent;\n    _this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n    _this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n    return _this;\n  }\n\n  _createClass(Request, [{\n    key: \"method\",\n    get: function get() {\n      return this[INTERNALS].method;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return formatUrl(this[INTERNALS].parsedURL);\n    }\n  }, {\n    key: \"headers\",\n    get: function get() {\n      return this[INTERNALS].headers;\n    }\n  }, {\n    key: \"redirect\",\n    get: function get() {\n      return this[INTERNALS].redirect;\n    }\n  }, {\n    key: \"signal\",\n    get: function get() {\n      return this[INTERNALS].signal;\n    }\n    /**\n     * Clone this request\n     *\n     * @return  Request\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Request(this);\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Request';\n    }\n  }]);\n\n  return Request;\n}(Body, Symbol.toStringTag);\n\nexport { Request as default };\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\n\nexport var getNodeRequestOptions = function getNodeRequestOptions(request) {\n  var parsedURL = request[INTERNALS].parsedURL;\n  var headers = new Headers(request[INTERNALS].headers); // Fetch step 1.3\n\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  } // HTTP-network-or-cache fetch steps 2.4-2.7\n\n\n  var contentLengthValue = null;\n\n  if (request.body === null && /^(post|put)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n\n  if (request.body !== null) {\n    var totalBytes = getTotalBytes(request); // Set Content-Length if totalBytes is a number (that is not NaN)\n\n    if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n\n  if (contentLengthValue) {\n    headers.set('Content-Length', contentLengthValue);\n  } // HTTP-network-or-cache fetch step 2.11\n\n\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', 'node-fetch');\n  } // HTTP-network-or-cache fetch step 2.15\n\n\n  if (request.compress && !headers.has('Accept-Encoding')) {\n    headers.set('Accept-Encoding', 'gzip,deflate,br');\n  }\n\n  var agent = request.agent;\n\n  if (typeof agent === 'function') {\n    agent = agent(parsedURL);\n  }\n\n  if (!headers.has('Connection') && !agent) {\n    headers.set('Connection', 'close');\n  } // HTTP-network fetch step 4.2\n  // chunked encoding is handled by Node.js\n\n\n  var search = getSearch(parsedURL); // Manually spread the URL object instead of spread syntax\n\n  var requestOptions = {\n    path: parsedURL.pathname + search,\n    pathname: parsedURL.pathname,\n    hostname: parsedURL.hostname,\n    protocol: parsedURL.protocol,\n    port: parsedURL.port,\n    hash: parsedURL.hash,\n    search: parsedURL.search,\n    query: parsedURL.query,\n    href: parsedURL.href,\n    method: request.method,\n    headers: headers[Symbol.for('nodejs.util.inspect.custom')](),\n    insecureHTTPParser: request.insecureHTTPParser,\n    agent: agent\n  };\n  return requestOptions;\n};","map":null,"metadata":{},"sourceType":"module"}