{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar logger = require(\"@sinonjs/commons\").deprecated;\n\nvar collectOwnMethods = require(\"./collect-own-methods\");\n\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n\nvar isPropertyConfigurable = require(\"./util/core/is-property-configurable\");\n\nvar match = require(\"@sinonjs/samsam\").createMatcher;\n\nvar sinonAssert = require(\"./assert\");\n\nvar sinonClock = require(\"./util/fake-timers\");\n\nvar sinonMock = require(\"./mock\");\n\nvar sinonSpy = require(\"./spy\");\n\nvar sinonStub = require(\"./stub\");\n\nvar sinonFake = require(\"./fake\");\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar fakeServer = require(\"nise\").fakeServer;\n\nvar fakeXhr = require(\"nise\").fakeXhr;\n\nvar usePromiseLibrary = require(\"./util/core/use-promise-library\");\n\nvar DEFAULT_LEAK_THRESHOLD = 10000;\nvar filter = arrayProto.filter;\nvar forEach = arrayProto.forEach;\nvar push = arrayProto.push;\nvar reverse = arrayProto.reverse;\n\nfunction applyOnEach(fakes, method) {\n  var matchingFakes = filter(fakes, function (fake) {\n    return typeof fake[method] === \"function\";\n  });\n  forEach(matchingFakes, function (fake) {\n    fake[method]();\n  });\n}\n\nfunction Sandbox() {\n  var sandbox = this;\n  var fakeRestorers = [];\n  var promiseLib;\n  var collection = [];\n  var loggedLeakWarning = false;\n  sandbox.leakThreshold = DEFAULT_LEAK_THRESHOLD;\n\n  function addToCollection(object) {\n    if (push(collection, object) > sandbox.leakThreshold && !loggedLeakWarning) {\n      // eslint-disable-next-line no-console\n      logger.printWarning(\"Potential memory leak detected; be sure to call restore() to clean up your sandbox. To suppress this warning, modify the leakThreshold property of your sandbox.\");\n      loggedLeakWarning = true;\n    }\n  }\n\n  sandbox.assert = sinonAssert.createAssertObject();\n  sandbox.serverPrototype = fakeServer; // this is for testing only\n\n  sandbox.getFakes = function getFakes() {\n    return collection;\n  }; // this is for testing only\n\n\n  sandbox.getRestorers = function () {\n    return fakeRestorers;\n  };\n\n  sandbox.createStubInstance = function createStubInstance() {\n    var stubbed = sinonStub.createStubInstance.apply(null, arguments);\n    var ownMethods = collectOwnMethods(stubbed);\n    forEach(ownMethods, function (method) {\n      addToCollection(method);\n    });\n    usePromiseLibrary(promiseLib, ownMethods);\n    return stubbed;\n  };\n\n  sandbox.inject = function inject(obj) {\n    obj.spy = function () {\n      return sandbox.spy.apply(null, arguments);\n    };\n\n    obj.stub = function () {\n      return sandbox.stub.apply(null, arguments);\n    };\n\n    obj.mock = function () {\n      return sandbox.mock.apply(null, arguments);\n    };\n\n    obj.createStubInstance = function () {\n      return sandbox.createStubInstance.apply(sandbox, arguments);\n    };\n\n    obj.fake = function () {\n      return sandbox.fake.apply(null, arguments);\n    };\n\n    obj.replace = function () {\n      return sandbox.replace.apply(null, arguments);\n    };\n\n    obj.replaceSetter = function () {\n      return sandbox.replaceSetter.apply(null, arguments);\n    };\n\n    obj.replaceGetter = function () {\n      return sandbox.replaceGetter.apply(null, arguments);\n    };\n\n    if (sandbox.clock) {\n      obj.clock = sandbox.clock;\n    }\n\n    if (sandbox.server) {\n      obj.server = sandbox.server;\n      obj.requests = sandbox.server.requests;\n    }\n\n    obj.match = match;\n    return obj;\n  };\n\n  sandbox.mock = function mock() {\n    var m = sinonMock.apply(null, arguments);\n    addToCollection(m);\n    usePromiseLibrary(promiseLib, m);\n    return m;\n  };\n\n  sandbox.reset = function reset() {\n    applyOnEach(collection, \"reset\");\n    applyOnEach(collection, \"resetHistory\");\n  };\n\n  sandbox.resetBehavior = function resetBehavior() {\n    applyOnEach(collection, \"resetBehavior\");\n  };\n\n  sandbox.resetHistory = function resetHistory() {\n    function privateResetHistory(f) {\n      var method = f.resetHistory || f.reset;\n\n      if (method) {\n        method.call(f);\n      }\n    }\n\n    forEach(collection, function (fake) {\n      if (typeof fake === \"function\") {\n        privateResetHistory(fake);\n        return;\n      }\n\n      var methods = [];\n\n      if (fake.get) {\n        push(methods, fake.get);\n      }\n\n      if (fake.set) {\n        push(methods, fake.set);\n      }\n\n      forEach(methods, privateResetHistory);\n    });\n  };\n\n  sandbox.restore = function restore() {\n    if (arguments.length) {\n      throw new Error(\"sandbox.restore() does not take any parameters. Perhaps you meant stub.restore()\");\n    }\n\n    reverse(collection);\n    applyOnEach(collection, \"restore\");\n    collection = [];\n    forEach(fakeRestorers, function (restorer) {\n      restorer();\n    });\n    fakeRestorers = [];\n    sandbox.restoreContext();\n  };\n\n  sandbox.restoreContext = function restoreContext() {\n    var injectedKeys = sandbox.injectedKeys;\n    var injectInto = sandbox.injectInto;\n\n    if (!injectedKeys) {\n      return;\n    }\n\n    forEach(injectedKeys, function (injectedKey) {\n      delete injectInto[injectedKey];\n    });\n    injectedKeys = [];\n  };\n\n  function getFakeRestorer(object, property) {\n    var descriptor = getPropertyDescriptor(object, property);\n\n    function restorer() {\n      if (descriptor.isOwn) {\n        Object.defineProperty(object, property, descriptor);\n      } else {\n        delete object[property];\n      }\n    }\n\n    restorer.object = object;\n    restorer.property = property;\n    return restorer;\n  }\n\n  function verifyNotReplaced(object, property) {\n    forEach(fakeRestorers, function (fakeRestorer) {\n      if (fakeRestorer.object === object && fakeRestorer.property === property) {\n        throw new TypeError(\"Attempted to replace \".concat(property, \" which is already replaced\"));\n      }\n    });\n  }\n\n  sandbox.replace = function replace(object, property, replacement) {\n    var descriptor = getPropertyDescriptor(object, property);\n\n    if (typeof descriptor === \"undefined\") {\n      throw new TypeError(\"Cannot replace non-existent property \".concat(valueToString(property)));\n    }\n\n    if (typeof replacement === \"undefined\") {\n      throw new TypeError(\"Expected replacement argument to be defined\");\n    }\n\n    if (typeof descriptor.get === \"function\") {\n      throw new Error(\"Use sandbox.replaceGetter for replacing getters\");\n    }\n\n    if (typeof descriptor.set === \"function\") {\n      throw new Error(\"Use sandbox.replaceSetter for replacing setters\");\n    }\n\n    if (_typeof(object[property]) !== _typeof(replacement)) {\n      throw new TypeError(\"Cannot replace \".concat(_typeof(object[property]), \" with \").concat(_typeof(replacement)));\n    }\n\n    verifyNotReplaced(object, property); // store a function for restoring the replaced property\n\n    push(fakeRestorers, getFakeRestorer(object, property));\n    object[property] = replacement;\n    return replacement;\n  };\n\n  sandbox.replaceGetter = function replaceGetter(object, property, replacement) {\n    var descriptor = getPropertyDescriptor(object, property);\n\n    if (typeof descriptor === \"undefined\") {\n      throw new TypeError(\"Cannot replace non-existent property \".concat(valueToString(property)));\n    }\n\n    if (typeof replacement !== \"function\") {\n      throw new TypeError(\"Expected replacement argument to be a function\");\n    }\n\n    if (typeof descriptor.get !== \"function\") {\n      throw new Error(\"`object.property` is not a getter\");\n    }\n\n    verifyNotReplaced(object, property); // store a function for restoring the replaced property\n\n    push(fakeRestorers, getFakeRestorer(object, property));\n    Object.defineProperty(object, property, {\n      get: replacement,\n      configurable: isPropertyConfigurable(object, property)\n    });\n    return replacement;\n  };\n\n  sandbox.replaceSetter = function replaceSetter(object, property, replacement) {\n    var descriptor = getPropertyDescriptor(object, property);\n\n    if (typeof descriptor === \"undefined\") {\n      throw new TypeError(\"Cannot replace non-existent property \".concat(valueToString(property)));\n    }\n\n    if (typeof replacement !== \"function\") {\n      throw new TypeError(\"Expected replacement argument to be a function\");\n    }\n\n    if (typeof descriptor.set !== \"function\") {\n      throw new Error(\"`object.property` is not a setter\");\n    }\n\n    verifyNotReplaced(object, property); // store a function for restoring the replaced property\n\n    push(fakeRestorers, getFakeRestorer(object, property)); // eslint-disable-next-line accessor-pairs\n\n    Object.defineProperty(object, property, {\n      set: replacement,\n      configurable: isPropertyConfigurable(object, property)\n    });\n    return replacement;\n  };\n\n  function commonPostInitSetup(args, spy) {\n    var object = args[0];\n    var property = args[1];\n    var isSpyingOnEntireObject = typeof property === \"undefined\" && _typeof(object) === \"object\";\n\n    if (isSpyingOnEntireObject) {\n      var ownMethods = collectOwnMethods(spy);\n      forEach(ownMethods, function (method) {\n        addToCollection(method);\n      });\n      usePromiseLibrary(promiseLib, ownMethods);\n    } else {\n      addToCollection(spy);\n      usePromiseLibrary(promiseLib, spy);\n    }\n\n    return spy;\n  }\n\n  sandbox.spy = function spy() {\n    var createdSpy = sinonSpy.apply(sinonSpy, arguments);\n    return commonPostInitSetup(arguments, createdSpy);\n  };\n\n  sandbox.stub = function stub() {\n    var createdStub = sinonStub.apply(sinonStub, arguments);\n    return commonPostInitSetup(arguments, createdStub);\n  }; // eslint-disable-next-line no-unused-vars\n\n\n  sandbox.fake = function fake(f) {\n    var s = sinonFake.apply(sinonFake, arguments);\n    addToCollection(s);\n    return s;\n  };\n\n  forEach(Object.keys(sinonFake), function (key) {\n    var fakeBehavior = sinonFake[key];\n\n    if (typeof fakeBehavior === \"function\") {\n      sandbox.fake[key] = function () {\n        var s = fakeBehavior.apply(fakeBehavior, arguments);\n        addToCollection(s);\n        return s;\n      };\n    }\n  });\n\n  sandbox.useFakeTimers = function useFakeTimers(args) {\n    var clock = sinonClock.useFakeTimers.call(null, args);\n    sandbox.clock = clock;\n    addToCollection(clock);\n    return clock;\n  };\n\n  sandbox.verify = function verify() {\n    applyOnEach(collection, \"verify\");\n  };\n\n  sandbox.verifyAndRestore = function verifyAndRestore() {\n    var exception;\n\n    try {\n      sandbox.verify();\n    } catch (e) {\n      exception = e;\n    }\n\n    sandbox.restore();\n\n    if (exception) {\n      throw exception;\n    }\n  };\n\n  sandbox.useFakeServer = function useFakeServer() {\n    var proto = sandbox.serverPrototype || fakeServer;\n\n    if (!proto || !proto.create) {\n      return null;\n    }\n\n    sandbox.server = proto.create();\n    addToCollection(sandbox.server);\n    return sandbox.server;\n  };\n\n  sandbox.useFakeXMLHttpRequest = function useFakeXMLHttpRequest() {\n    var xhr = fakeXhr.useFakeXMLHttpRequest();\n    addToCollection(xhr);\n    return xhr;\n  };\n\n  sandbox.usingPromise = function usingPromise(promiseLibrary) {\n    promiseLib = promiseLibrary;\n    collection.promiseLibrary = promiseLibrary;\n    return sandbox;\n  };\n}\n\nSandbox.prototype.match = match;\nmodule.exports = Sandbox;","map":null,"metadata":{},"sourceType":"module"}