{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar color = require(\"./color\");\n\nvar match = require(\"@sinonjs/samsam\").createMatcher;\n\nvar timesInWords = require(\"./util/core/times-in-words\");\n\nvar sinonFormat = require(\"./util/core/format\");\n\nvar jsDiff = require(\"diff\");\n\nvar join = arrayProto.join;\nvar map = arrayProto.map;\nvar push = arrayProto.push;\nvar slice = arrayProto.slice;\n\nfunction colorSinonMatchText(matcher, calledArg, calledArgMessage) {\n  var calledArgumentMessage = calledArgMessage;\n\n  if (!matcher.test(calledArg)) {\n    matcher.message = color.red(matcher.message);\n\n    if (calledArgumentMessage) {\n      calledArgumentMessage = color.green(calledArgumentMessage);\n    }\n  }\n\n  return \"\".concat(calledArgumentMessage, \" \").concat(matcher.message);\n}\n\nfunction colorDiffText(diff) {\n  var objects = map(diff, function (part) {\n    var text = part.value;\n\n    if (part.added) {\n      text = color.green(text);\n    } else if (part.removed) {\n      text = color.red(text);\n    }\n\n    if (diff.length === 2) {\n      text += \" \"; // format simple diffs\n    }\n\n    return text;\n  });\n  return join(objects, \"\");\n}\n\nfunction quoteStringValue(value) {\n  if (typeof value === \"string\") {\n    return JSON.stringify(value);\n  }\n\n  return value;\n}\n\nmodule.exports = {\n  c: function c(spyInstance) {\n    return timesInWords(spyInstance.callCount);\n  },\n  n: function n(spyInstance) {\n    // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n    return spyInstance.toString();\n  },\n  D: function D(spyInstance, args) {\n    var message = \"\";\n\n    for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n      // describe multiple calls\n      if (l > 1) {\n        message += \"\\nCall \".concat(i + 1, \":\");\n      }\n\n      var calledArgs = spyInstance.getCall(i).args;\n      var expectedArgs = slice(args);\n\n      for (var j = 0; j < calledArgs.length || j < expectedArgs.length; ++j) {\n        if (calledArgs[j]) {\n          calledArgs[j] = quoteStringValue(calledArgs[j]);\n        }\n\n        if (expectedArgs[j]) {\n          expectedArgs[j] = quoteStringValue(expectedArgs[j]);\n        }\n\n        message += \"\\n\";\n        var calledArgMessage = j < calledArgs.length ? sinonFormat(calledArgs[j]) : \"\";\n\n        if (match.isMatcher(expectedArgs[j])) {\n          message += colorSinonMatchText(expectedArgs[j], calledArgs[j], calledArgMessage);\n        } else {\n          var expectedArgMessage = j < expectedArgs.length ? sinonFormat(expectedArgs[j]) : \"\";\n          var diff = jsDiff.diffJson(calledArgMessage, expectedArgMessage);\n          message += colorDiffText(diff);\n        }\n      }\n    }\n\n    return message;\n  },\n  C: function C(spyInstance) {\n    var calls = [];\n\n    for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n      var stringifiedCall = \"    \".concat(spyInstance.getCall(i).toString());\n\n      if (/\\n/.test(calls[i - 1])) {\n        stringifiedCall = \"\\n\".concat(stringifiedCall);\n      }\n\n      push(calls, stringifiedCall);\n    }\n\n    return calls.length > 0 ? \"\\n\".concat(join(calls, \"\\n\")) : \"\";\n  },\n  t: function t(spyInstance) {\n    var objects = [];\n\n    for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n      push(objects, sinonFormat(spyInstance.thisValues[i]));\n    }\n\n    return join(objects, \", \");\n  },\n  \"*\": function _(spyInstance, args) {\n    return join(map(args, function (arg) {\n      return sinonFormat(arg);\n    }), \", \");\n  }\n};","map":null,"metadata":{},"sourceType":"module"}