{"ast":null,"code":"\"use strict\";\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar mockExpectation = require(\"./mock-expectation\");\n\nvar proxyCallToString = require(\"./proxy-call\").toString;\n\nvar extend = require(\"./util/core/extend\");\n\nvar deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n\nvar wrapMethod = require(\"./util/core/wrap-method\");\n\nvar usePromiseLibrary = require(\"./util/core/use-promise-library\");\n\nvar concat = arrayProto.concat;\nvar filter = arrayProto.filter;\nvar forEach = arrayProto.forEach;\nvar every = arrayProto.every;\nvar join = arrayProto.join;\nvar push = arrayProto.push;\nvar slice = arrayProto.slice;\nvar unshift = arrayProto.unshift;\n\nfunction mock(object) {\n  if (!object || typeof object === \"string\") {\n    return mockExpectation.create(object ? object : \"Anonymous mock\");\n  }\n\n  return mock.create(object);\n}\n\nfunction each(collection, callback) {\n  var col = collection || [];\n  forEach(col, callback);\n}\n\nfunction arrayEquals(arr1, arr2, compareLength) {\n  if (compareLength && arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return every(arr1, function (element, i) {\n    return deepEqual(arr2[i], element);\n  });\n}\n\nextend(mock, {\n  create: function create(object) {\n    if (!object) {\n      throw new TypeError(\"object is null\");\n    }\n\n    var mockObject = extend.nonEnum({}, mock, {\n      object: object\n    });\n    delete mockObject.create;\n    return mockObject;\n  },\n  expects: function expects(method) {\n    if (!method) {\n      throw new TypeError(\"method is falsy\");\n    }\n\n    if (!this.expectations) {\n      this.expectations = {};\n      this.proxies = [];\n      this.failures = [];\n    }\n\n    if (!this.expectations[method]) {\n      this.expectations[method] = [];\n      var mockObject = this;\n      wrapMethod(this.object, method, function () {\n        return mockObject.invokeMethod(method, this, arguments);\n      });\n      push(this.proxies, method);\n    }\n\n    var expectation = mockExpectation.create(method);\n    expectation.wrappedMethod = this.object[method].wrappedMethod;\n    push(this.expectations[method], expectation);\n    usePromiseLibrary(this.promiseLibrary, expectation);\n    return expectation;\n  },\n  restore: function restore() {\n    var object = this.object;\n    each(this.proxies, function (proxy) {\n      if (typeof object[proxy].restore === \"function\") {\n        object[proxy].restore();\n      }\n    });\n  },\n  verify: function verify() {\n    var expectations = this.expectations || {};\n    var messages = this.failures ? slice(this.failures) : [];\n    var met = [];\n    each(this.proxies, function (proxy) {\n      each(expectations[proxy], function (expectation) {\n        if (!expectation.met()) {\n          push(messages, String(expectation));\n        } else {\n          push(met, String(expectation));\n        }\n      });\n    });\n    this.restore();\n\n    if (messages.length > 0) {\n      mockExpectation.fail(join(concat(messages, met), \"\\n\"));\n    } else if (met.length > 0) {\n      mockExpectation.pass(join(concat(messages, met), \"\\n\"));\n    }\n\n    return true;\n  },\n  usingPromise: function usingPromise(promiseLibrary) {\n    this.promiseLibrary = promiseLibrary;\n    return this;\n  },\n  invokeMethod: function invokeMethod(method, thisValue, args) {\n    /* if we cannot find any matching files we will explicitly call mockExpection#fail with error messages */\n\n    /* eslint consistent-return: \"off\" */\n    var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];\n    var currentArgs = args || [];\n    var available;\n    var expectationsWithMatchingArgs = filter(expectations, function (expectation) {\n      var expectedArgs = expectation.expectedArguments || [];\n      return arrayEquals(expectedArgs, currentArgs, expectation.expectsExactArgCount);\n    });\n    var expectationsToApply = filter(expectationsWithMatchingArgs, function (expectation) {\n      return !expectation.met() && expectation.allowsCall(thisValue, args);\n    });\n\n    if (expectationsToApply.length > 0) {\n      return expectationsToApply[0].apply(thisValue, args);\n    }\n\n    var messages = [];\n    var exhausted = 0;\n    forEach(expectationsWithMatchingArgs, function (expectation) {\n      if (expectation.allowsCall(thisValue, args)) {\n        available = available || expectation;\n      } else {\n        exhausted += 1;\n      }\n    });\n\n    if (available && exhausted === 0) {\n      return available.apply(thisValue, args);\n    }\n\n    forEach(expectations, function (expectation) {\n      push(messages, \"    \".concat(String(expectation)));\n    });\n    unshift(messages, \"Unexpected call: \".concat(proxyCallToString.call({\n      proxy: method,\n      args: args\n    })));\n    var err = new Error();\n\n    if (!err.stack) {\n      // PhantomJS does not serialize the stack trace until the error has been thrown\n      try {\n        throw err;\n      } catch (e) {\n        /* empty */\n      }\n    }\n\n    push(this.failures, \"Unexpected call: \".concat(proxyCallToString.call({\n      proxy: method,\n      args: args,\n      stack: err.stack\n    })));\n    mockExpectation.fail(join(messages, \"\\n\"));\n  }\n});\nmodule.exports = mock;","map":null,"metadata":{},"sourceType":"module"}