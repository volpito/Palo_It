{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar proxyCallUtil = require(\"./proxy-call-util\");\n\nvar push = arrayProto.push;\nvar forEach = arrayProto.forEach;\nvar concat = arrayProto.concat;\nvar ErrorConstructor = Error.prototype.constructor;\nvar bind = Function.prototype.bind;\nvar callId = 0;\n\nmodule.exports = function invoke(func, thisValue, args) {\n  var matchings = this.matchingFakes(args);\n  var currentCallId = callId++;\n  var exception, returnValue;\n  proxyCallUtil.incrementCallCount(this);\n  push(this.thisValues, thisValue);\n  push(this.args, args);\n  push(this.callIds, currentCallId);\n  forEach(matchings, function (matching) {\n    proxyCallUtil.incrementCallCount(matching);\n    push(matching.thisValues, thisValue);\n    push(matching.args, args);\n    push(matching.callIds, currentCallId);\n  }); // Make call properties available from within the spied function:\n\n  proxyCallUtil.createCallProperties(this);\n  forEach(matchings, proxyCallUtil.createCallProperties);\n\n  try {\n    this.invoking = true;\n    var thisCall = this.getCall(this.callCount - 1);\n\n    if (thisCall.calledWithNew()) {\n      // Call through with `new`\n      returnValue = new (bind.apply(this.func || func, concat([thisValue], args)))();\n\n      if (_typeof(returnValue) !== \"object\") {\n        returnValue = thisValue;\n      }\n    } else {\n      returnValue = (this.func || func).apply(thisValue, args);\n    }\n  } catch (e) {\n    exception = e;\n  } finally {\n    delete this.invoking;\n  }\n\n  push(this.exceptions, exception);\n  push(this.returnValues, returnValue);\n  forEach(matchings, function (matching) {\n    push(matching.exceptions, exception);\n    push(matching.returnValues, returnValue);\n  });\n  var err = new ErrorConstructor(); // 1. Please do not get stack at this point. It may be so very slow, and not actually used\n  // 2. PhantomJS does not serialize the stack trace until the error has been thrown:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack\n\n  try {\n    throw err;\n  } catch (e) {\n    /* empty */\n  }\n\n  push(this.errorsWithCallStack, err);\n  forEach(matchings, function (matching) {\n    push(matching.errorsWithCallStack, err);\n  }); // Make return value and exception available in the calls:\n\n  proxyCallUtil.createCallProperties(this);\n  forEach(matchings, proxyCallUtil.createCallProperties);\n\n  if (exception !== undefined) {\n    throw exception;\n  }\n\n  return returnValue;\n};","map":null,"metadata":{},"sourceType":"module"}