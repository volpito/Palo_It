{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar indexOf = require(\"@sinonjs/commons\").prototypes.string.indexOf;\n\nvar forEach = require(\"@sinonjs/commons\").prototypes.array.forEach;\n\nvar type = require(\"type-detect\");\n\nvar engineCanCompareMaps = typeof Array.from === \"function\";\n\nvar deepEqual = require(\"./deep-equal\").use(match); // eslint-disable-line no-use-before-define\n\n\nvar isArrayType = require(\"./is-array-type\");\n\nvar isSubset = require(\"./is-subset\");\n\nvar createMatcher = require(\"./create-matcher\");\n/**\n * Returns true when `array` contains all of `subset` as defined by the `compare`\n * argument\n *\n * @param  {Array} array   An array to search for a subset\n * @param  {Array} subset  The subset to find in the array\n * @param  {Function} compare A comparison function\n * @returns {boolean}         [description]\n * @private\n */\n\n\nfunction arrayContains(array, subset, compare) {\n  if (subset.length === 0) {\n    return true;\n  }\n\n  var i, l, j, k;\n\n  for (i = 0, l = array.length; i < l; ++i) {\n    if (compare(array[i], subset[0])) {\n      for (j = 0, k = subset.length; j < k; ++j) {\n        if (i + j >= l) {\n          return false;\n        }\n\n        if (!compare(array[i + j], subset[j])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/* eslint-disable complexity */\n\n/**\n * Matches an object with a matcher (or value)\n *\n * @alias module:samsam.match\n * @param {object} object The object candidate to match\n * @param {object} matcherOrValue A matcher or value to match against\n * @returns {boolean} true when `object` matches `matcherOrValue`\n */\n\n\nfunction match(object, matcherOrValue) {\n  if (matcherOrValue && typeof matcherOrValue.test === \"function\") {\n    return matcherOrValue.test(object);\n  }\n\n  switch (type(matcherOrValue)) {\n    case \"bigint\":\n    case \"boolean\":\n    case \"number\":\n    case \"symbol\":\n      return matcherOrValue === object;\n\n    case \"function\":\n      return matcherOrValue(object) === true;\n\n    case \"string\":\n      var notNull = typeof object === \"string\" || Boolean(object);\n      return notNull && indexOf(valueToString(object).toLowerCase(), matcherOrValue.toLowerCase()) >= 0;\n\n    case \"null\":\n      return object === null;\n\n    case \"undefined\":\n      return typeof object === \"undefined\";\n\n    case \"Date\":\n      /* istanbul ignore else */\n      if (type(object) === \"Date\") {\n        return object.getTime() === matcherOrValue.getTime();\n      }\n      /* istanbul ignore next: this is basically the rest of the function, which is covered */\n\n\n      break;\n\n    case \"Array\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n      return isArrayType(matcherOrValue) && arrayContains(object, matcherOrValue, match);\n\n    case \"Map\":\n      /* istanbul ignore next: this is covered by a test, that is only run in IE, but we collect coverage information in node*/\n      if (!engineCanCompareMaps) {\n        throw new Error(\"The JavaScript engine does not support Array.from and cannot reliably do value comparison of Map instances\");\n      }\n\n      return type(object) === \"Map\" && arrayContains(Array.from(object), Array.from(matcherOrValue), match);\n\n    default:\n      break;\n  }\n\n  switch (type(object)) {\n    case \"null\":\n      return false;\n\n    case \"Set\":\n      return isSubset(matcherOrValue, object, match);\n\n    default:\n      break;\n  }\n  /* istanbul ignore else */\n\n\n  if (matcherOrValue && _typeof(matcherOrValue) === \"object\") {\n    if (matcherOrValue === object) {\n      return true;\n    }\n\n    if (_typeof(object) !== \"object\") {\n      return false;\n    }\n\n    var prop; // eslint-disable-next-line guard-for-in\n\n    for (prop in matcherOrValue) {\n      var value = object[prop];\n\n      if (typeof value === \"undefined\" && typeof object.getAttribute === \"function\") {\n        value = object.getAttribute(prop);\n      }\n\n      if (matcherOrValue[prop] === null || typeof matcherOrValue[prop] === \"undefined\") {\n        if (value !== matcherOrValue[prop]) {\n          return false;\n        }\n      } else if (typeof value === \"undefined\" || !deepEqual(value, matcherOrValue[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Matcher was an unknown or unsupported type\");\n}\n/* eslint-enable complexity */\n\n\nforEach(Object.keys(createMatcher), function (key) {\n  match[key] = createMatcher[key];\n});\nmodule.exports = match;","map":null,"metadata":{},"sourceType":"module"}