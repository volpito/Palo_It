{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n\nvar deepEqual = require(\"./deep-equal\").use(createMatcher); // eslint-disable-line no-use-before-define\n\n\nvar every = require(\"@sinonjs/commons\").every;\n\nvar functionName = require(\"@sinonjs/commons\").functionName;\n\nvar get = require(\"lodash.get\");\n\nvar iterableToString = require(\"./iterable-to-string\");\n\nvar objectProto = require(\"@sinonjs/commons\").prototypes.object;\n\nvar typeOf = require(\"@sinonjs/commons\").typeOf;\n\nvar valueToString = require(\"@sinonjs/commons\").valueToString;\n\nvar assertMatcher = require(\"./create-matcher/assert-matcher\");\n\nvar assertMethodExists = require(\"./create-matcher/assert-method-exists\");\n\nvar assertType = require(\"./create-matcher/assert-type\");\n\nvar isIterable = require(\"./create-matcher/is-iterable\");\n\nvar isMatcher = require(\"./create-matcher/is-matcher\");\n\nvar matcherPrototype = require(\"./create-matcher/matcher-prototype\");\n\nvar arrayIndexOf = arrayProto.indexOf;\nvar some = arrayProto.some;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar objectToString = objectProto.toString;\n\nvar TYPE_MAP = require(\"./create-matcher/type-map\")(createMatcher); // eslint-disable-line no-use-before-define\n\n/**\n * Creates a matcher object for the passed expectation\n *\n * @alias module:samsam.createMatcher\n * @param {*} expectation An expecttation\n * @param {string} message A message for the expectation\n * @returns {object} A matcher object\n */\n\n\nfunction createMatcher(expectation, message) {\n  var m = Object.create(matcherPrototype);\n  var type = typeOf(expectation);\n\n  if (message !== undefined && typeof message !== \"string\") {\n    throw new TypeError(\"Message should be a string\");\n  }\n\n  if (arguments.length > 2) {\n    throw new TypeError(\"Expected 1 or 2 arguments, received \".concat(arguments.length));\n  }\n\n  if (type in TYPE_MAP) {\n    TYPE_MAP[type](m, expectation, message);\n  } else {\n    m.test = function (actual) {\n      return deepEqual(actual, expectation);\n    };\n  }\n\n  if (!m.message) {\n    m.message = \"match(\".concat(valueToString(expectation), \")\");\n  }\n\n  return m;\n}\n\ncreateMatcher.isMatcher = isMatcher;\ncreateMatcher.any = createMatcher(function () {\n  return true;\n}, \"any\");\ncreateMatcher.defined = createMatcher(function (actual) {\n  return actual !== null && actual !== undefined;\n}, \"defined\");\ncreateMatcher.truthy = createMatcher(function (actual) {\n  return Boolean(actual);\n}, \"truthy\");\ncreateMatcher.falsy = createMatcher(function (actual) {\n  return !actual;\n}, \"falsy\");\n\ncreateMatcher.same = function (expectation) {\n  return createMatcher(function (actual) {\n    return expectation === actual;\n  }, \"same(\".concat(valueToString(expectation), \")\"));\n};\n\ncreateMatcher.in = function (arrayOfExpectations) {\n  if (typeOf(arrayOfExpectations) !== \"array\") {\n    throw new TypeError(\"array expected\");\n  }\n\n  return createMatcher(function (actual) {\n    return some(arrayOfExpectations, function (expectation) {\n      return expectation === actual;\n    });\n  }, \"in(\".concat(valueToString(arrayOfExpectations), \")\"));\n};\n\ncreateMatcher.typeOf = function (type) {\n  assertType(type, \"string\", \"type\");\n  return createMatcher(function (actual) {\n    return typeOf(actual) === type;\n  }, \"typeOf(\\\"\".concat(type, \"\\\")\"));\n};\n\ncreateMatcher.instanceOf = function (type) {\n  /* istanbul ignore if */\n  if (typeof Symbol === \"undefined\" || typeof Symbol.hasInstance === \"undefined\") {\n    assertType(type, \"function\", \"type\");\n  } else {\n    assertMethodExists(type, Symbol.hasInstance, \"type\", \"[Symbol.hasInstance]\");\n  }\n\n  return createMatcher(function (actual) {\n    return actual instanceof type;\n  }, \"instanceOf(\".concat(functionName(type) || objectToString(type), \")\"));\n};\n/**\n * Creates a property matcher\n *\n * @private\n * @param {Function} propertyTest A function to test the property against a value\n * @param {string} messagePrefix A prefix to use for messages generated by the matcher\n * @returns {object} A matcher\n */\n\n\nfunction createPropertyMatcher(propertyTest, messagePrefix) {\n  return function (property, value) {\n    assertType(property, \"string\", \"property\");\n    var onlyProperty = arguments.length === 1;\n    var message = \"\".concat(messagePrefix, \"(\\\"\").concat(property, \"\\\"\");\n\n    if (!onlyProperty) {\n      message += \", \".concat(valueToString(value));\n    }\n\n    message += \")\";\n    return createMatcher(function (actual) {\n      if (actual === undefined || actual === null || !propertyTest(actual, property)) {\n        return false;\n      }\n\n      return onlyProperty || deepEqual(actual[property], value);\n    }, message);\n  };\n}\n\ncreateMatcher.has = createPropertyMatcher(function (actual, property) {\n  if (_typeof(actual) === \"object\") {\n    return property in actual;\n  }\n\n  return actual[property] !== undefined;\n}, \"has\");\ncreateMatcher.hasOwn = createPropertyMatcher(function (actual, property) {\n  return hasOwnProperty(actual, property);\n}, \"hasOwn\");\n\ncreateMatcher.hasNested = function (property, value) {\n  assertType(property, \"string\", \"property\");\n  var onlyProperty = arguments.length === 1;\n  var message = \"hasNested(\\\"\".concat(property, \"\\\"\");\n\n  if (!onlyProperty) {\n    message += \", \".concat(valueToString(value));\n  }\n\n  message += \")\";\n  return createMatcher(function (actual) {\n    if (actual === undefined || actual === null || get(actual, property) === undefined) {\n      return false;\n    }\n\n    return onlyProperty || deepEqual(get(actual, property), value);\n  }, message);\n};\n\nvar jsonParseResultTypes = {\n  null: true,\n  boolean: true,\n  number: true,\n  string: true,\n  object: true,\n  array: true\n};\n\ncreateMatcher.json = function (value) {\n  if (!jsonParseResultTypes[typeOf(value)]) {\n    throw new TypeError(\"Value cannot be the result of JSON.parse\");\n  }\n\n  var message = \"json(\".concat(JSON.stringify(value, null, \"  \"), \")\");\n  return createMatcher(function (actual) {\n    var parsed;\n\n    try {\n      parsed = JSON.parse(actual);\n    } catch (e) {\n      return false;\n    }\n\n    return deepEqual(parsed, value);\n  }, message);\n};\n\ncreateMatcher.every = function (predicate) {\n  assertMatcher(predicate);\n  return createMatcher(function (actual) {\n    if (typeOf(actual) === \"object\") {\n      return every(Object.keys(actual), function (key) {\n        return predicate.test(actual[key]);\n      });\n    }\n\n    return isIterable(actual) && every(actual, function (element) {\n      return predicate.test(element);\n    });\n  }, \"every(\".concat(predicate.message, \")\"));\n};\n\ncreateMatcher.some = function (predicate) {\n  assertMatcher(predicate);\n  return createMatcher(function (actual) {\n    if (typeOf(actual) === \"object\") {\n      return !every(Object.keys(actual), function (key) {\n        return !predicate.test(actual[key]);\n      });\n    }\n\n    return isIterable(actual) && !every(actual, function (element) {\n      return !predicate.test(element);\n    });\n  }, \"some(\".concat(predicate.message, \")\"));\n};\n\ncreateMatcher.array = createMatcher.typeOf(\"array\");\n\ncreateMatcher.array.deepEquals = function (expectation) {\n  return createMatcher(function (actual) {\n    // Comparing lengths is the fastest way to spot a difference before iterating through every item\n    var sameLength = actual.length === expectation.length;\n    return typeOf(actual) === \"array\" && sameLength && every(actual, function (element, index) {\n      var expected = expectation[index];\n      return typeOf(expected) === \"array\" && typeOf(element) === \"array\" ? createMatcher.array.deepEquals(expected).test(element) : deepEqual(expected, element);\n    });\n  }, \"deepEquals([\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.array.startsWith = function (expectation) {\n  return createMatcher(function (actual) {\n    return typeOf(actual) === \"array\" && every(expectation, function (expectedElement, index) {\n      return actual[index] === expectedElement;\n    });\n  }, \"startsWith([\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.array.endsWith = function (expectation) {\n  return createMatcher(function (actual) {\n    // This indicates the index in which we should start matching\n    var offset = actual.length - expectation.length;\n    return typeOf(actual) === \"array\" && every(expectation, function (expectedElement, index) {\n      return actual[offset + index] === expectedElement;\n    });\n  }, \"endsWith([\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.array.contains = function (expectation) {\n  return createMatcher(function (actual) {\n    return typeOf(actual) === \"array\" && every(expectation, function (expectedElement) {\n      return arrayIndexOf(actual, expectedElement) !== -1;\n    });\n  }, \"contains([\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.map = createMatcher.typeOf(\"map\");\n\ncreateMatcher.map.deepEquals = function mapDeepEquals(expectation) {\n  return createMatcher(function (actual) {\n    // Comparing lengths is the fastest way to spot a difference before iterating through every item\n    var sameLength = actual.size === expectation.size;\n    return typeOf(actual) === \"map\" && sameLength && every(actual, function (element, key) {\n      return expectation.has(key) && expectation.get(key) === element;\n    });\n  }, \"deepEquals(Map[\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.map.contains = function mapContains(expectation) {\n  return createMatcher(function (actual) {\n    return typeOf(actual) === \"map\" && every(expectation, function (element, key) {\n      return actual.has(key) && actual.get(key) === element;\n    });\n  }, \"contains(Map[\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.set = createMatcher.typeOf(\"set\");\n\ncreateMatcher.set.deepEquals = function setDeepEquals(expectation) {\n  return createMatcher(function (actual) {\n    // Comparing lengths is the fastest way to spot a difference before iterating through every item\n    var sameLength = actual.size === expectation.size;\n    return typeOf(actual) === \"set\" && sameLength && every(actual, function (element) {\n      return expectation.has(element);\n    });\n  }, \"deepEquals(Set[\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.set.contains = function setContains(expectation) {\n  return createMatcher(function (actual) {\n    return typeOf(actual) === \"set\" && every(expectation, function (element) {\n      return actual.has(element);\n    });\n  }, \"contains(Set[\".concat(iterableToString(expectation), \"])\"));\n};\n\ncreateMatcher.bool = createMatcher.typeOf(\"boolean\");\ncreateMatcher.number = createMatcher.typeOf(\"number\");\ncreateMatcher.string = createMatcher.typeOf(\"string\");\ncreateMatcher.object = createMatcher.typeOf(\"object\");\ncreateMatcher.func = createMatcher.typeOf(\"function\");\ncreateMatcher.regexp = createMatcher.typeOf(\"regexp\");\ncreateMatcher.date = createMatcher.typeOf(\"date\");\ncreateMatcher.symbol = createMatcher.typeOf(\"symbol\");\nmodule.exports = createMatcher;","map":null,"metadata":{},"sourceType":"module"}